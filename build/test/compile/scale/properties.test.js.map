{"version":3,"file":"properties.test.js","sourceRoot":"","sources":["../../../../test/compile/scale/properties.test.ts"],"names":[],"mappings":"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","sourcesContent":["/* tslint:disable:quotemark */\n\nimport {Channel, NONPOSITION_SCALE_CHANNELS} from '../../../src/channel';\nimport * as rules from '../../../src/compile/scale/properties';\nimport {AREA, BAR, LINE} from '../../../src/mark';\nimport {ScaleType} from '../../../src/scale';\n\ndescribe('compile/scale', () => {\n  describe('nice', () => {\n    it('should return nice for x and y.', () => {\n      for (const c of ['x', 'y'] as Channel[]) {\n        expect(rules.nice('linear', c, {type: 'quantitative'})).toEqual(true);\n      }\n    });\n\n    it('should not return nice for binned x and y.', () => {\n      for (const c of ['x', 'y'] as Channel[]) {\n        expect(rules.nice('linear', c, {type: 'quantitative', bin: true})).toEqual(undefined);\n      }\n    });\n\n    it('should not return nice for temporal x and y.', () => {\n      for (const c of ['x', 'y'] as Channel[]) {\n        expect(rules.nice('time', c, {type: 'temporal'})).toEqual(undefined);\n      }\n    });\n  });\n\n  describe('padding', () => {\n    it('should be pointPadding for point scale if channel is x or y and padding is not specified.', () => {\n      for (const c of ['x', 'y'] as Channel[]) {\n        expect(rules.padding(c, 'point', {pointPadding: 13}, undefined, undefined, undefined)).toEqual(13);\n      }\n    });\n\n    it('should be continuousBandSize for linear x-scale of vertical bar.', () => {\n      expect(\n        rules.padding(\n          'x',\n          'linear',\n          {},\n          {field: 'date', type: 'temporal'},\n          {type: 'bar', orient: 'vertical'},\n          {continuousBandSize: 13}\n        )\n      ).toEqual(13);\n    });\n\n    it('should be undefined for linear x-scale for binned field of vertical bar.', () => {\n      expect(\n        rules.padding(\n          'x',\n          'linear',\n          {},\n          {bin: true, field: 'date', type: 'temporal'},\n          {type: 'bar', orient: 'vertical'},\n          {continuousBandSize: 13}\n        )\n      ).toEqual(undefined);\n    });\n\n    it('should be continuousBandSize for linear y-scale of horizontal bar.', () => {\n      expect(\n        rules.padding(\n          'y',\n          'linear',\n          {},\n          {field: 'date', type: 'temporal'},\n          {type: 'bar', orient: 'horizontal'},\n          {continuousBandSize: 13}\n        )\n      ).toEqual(13);\n    });\n  });\n\n  describe('paddingInner', () => {\n    it('should be undefined if padding is specified.', () => {\n      expect(rules.paddingInner(10, 'x', 'bar', {})).toEqual(undefined);\n    });\n\n    it('should be bandPaddingInner if channel is x or y and padding is not specified.', () => {\n      expect(rules.paddingInner(undefined, 'x', 'bar', {bandPaddingInner: 15})).toEqual(15);\n      expect(rules.paddingInner(undefined, 'y', 'bar', {bandPaddingInner: 15})).toEqual(15);\n    });\n\n    it('should be undefined for non-xy channels.', () => {\n      for (const c of NONPOSITION_SCALE_CHANNELS) {\n        expect(rules.paddingInner(undefined, c, 'bar', {bandPaddingInner: 15})).toEqual(undefined);\n      }\n    });\n  });\n\n  describe('paddingOuter', () => {\n    it('should be undefined if padding is specified.', () => {\n      for (const scaleType of ['point', 'band'] as ScaleType[]) {\n        expect(rules.paddingOuter(10, 'x', scaleType, 'bar', 0, {})).toEqual(undefined);\n      }\n    });\n\n    it('should be config.scale.bandPaddingOuter for band scale if channel is x or y and padding is not specified and config.scale.bandPaddingOuter.', () => {\n      for (const c of ['x', 'y'] as Channel[]) {\n        expect(rules.paddingOuter(undefined, c, 'band', 'bar', 0, {bandPaddingOuter: 16})).toEqual(16);\n      }\n    });\n    it('should be paddingInner/2 for band scale if channel is x or y and padding is not specified and config.scale.bandPaddingOuter.', () => {\n      for (const c of ['x', 'y'] as Channel[]) {\n        expect(rules.paddingOuter(undefined, c, 'band', 'bar', 10, {})).toEqual(5);\n      }\n    });\n\n    it('should be undefined for non-xy channels.', () => {\n      for (const c of NONPOSITION_SCALE_CHANNELS) {\n        for (const scaleType of ['point', 'band'] as ScaleType[]) {\n          expect(rules.paddingOuter(undefined, c, scaleType, 'bar', 0, {})).toEqual(undefined);\n        }\n      }\n    });\n  });\n\n  describe('reverse', () => {\n    it('should return true for a continuous scale with sort = \"descending\".', () => {\n      expect(rules.reverse('linear', 'descending')).toBe(true);\n    });\n\n    it('should return false for a discrete scale with sort = \"descending\".', () => {\n      expect(rules.reverse('point', 'descending')).not.toBeDefined();\n    });\n  });\n\n  describe('interpolate', () => {\n    it('should return hcl for continuous color scale', () => {\n      expect(rules.interpolate('color', 'linear')).toEqual('hcl');\n    });\n\n    it('should return undefined for discrete color scale', () => {\n      expect(rules.interpolate('color', 'sequential')).not.toBeDefined();\n    });\n  });\n\n  describe('zero', () => {\n    it('should return true when mapping a quantitative field to x with scale.domain = \"unaggregated\"', () => {\n      expect(\n        rules.zero('x', {field: 'a', type: 'quantitative'}, 'unaggregated', {type: 'point'}, 'linear')\n      ).toBeTruthy();\n    });\n\n    it('should return true when mapping a quantitative field to size', () => {\n      expect(rules.zero('size', {field: 'a', type: 'quantitative'}, undefined, {type: 'point'}, 'linear')).toBeTruthy();\n    });\n\n    it('should return false when mapping a ordinal field to size', () => {\n      expect(!rules.zero('size', {field: 'a', type: 'ordinal'}, undefined, {type: 'point'}, 'linear')).toBeTruthy();\n    });\n\n    it('should return true when mapping a non-binned quantitative field to x/y of point', () => {\n      for (const channel of ['x', 'y'] as Channel[]) {\n        expect(\n          rules.zero(channel, {field: 'a', type: 'quantitative'}, undefined, {type: 'point'}, 'linear')\n        ).toBeTruthy();\n      }\n    });\n\n    it('should return false when mapping a quantitative field to dimension axis of bar, line, and area', () => {\n      for (const mark of [BAR, AREA, LINE]) {\n        expect(\n          rules.zero('x', {field: 'a', type: 'quantitative'}, undefined, {type: mark, orient: 'vertical'}, 'linear')\n        ).toBe(false);\n        expect(\n          rules.zero('y', {field: 'a', type: 'quantitative'}, undefined, {type: mark, orient: 'horizontal'}, 'linear')\n        ).toBe(false);\n      }\n    });\n\n    it('should return false when mapping a binned quantitative field to x/y', () => {\n      for (const channel of ['x', 'y'] as Channel[]) {\n        expect(\n          !rules.zero(channel, {bin: true, field: 'a', type: 'quantitative'}, undefined, {type: 'point'}, 'linear')\n        ).toBeTruthy();\n      }\n    });\n\n    it('should return false when mapping a non-binned quantitative field with custom domain to x/y', () => {\n      for (const channel of ['x', 'y'] as Channel[]) {\n        expect(\n          !rules.zero(\n            channel,\n            {\n              bin: true,\n              field: 'a',\n              type: 'quantitative'\n            },\n            [3, 5],\n            {type: 'point'},\n            'linear'\n          )\n        ).toBeTruthy();\n      }\n    });\n  });\n});\n"]}