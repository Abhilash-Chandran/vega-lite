{"version":3,"file":"filterinvalid.js","sourceRoot":"","sources":["../../../../src/compile/data/filterinvalid.ts"],"names":[],"mappings":";AAAA,OAAO,EAAC,cAAc,EAAC,MAAM,eAAe,CAAC;AAC7C,OAAO,EAAW,OAAO,IAAI,QAAQ,EAAC,MAAM,gBAAgB,CAAC;AAC7D,OAAO,EAAC,UAAU,EAAC,MAAM,YAAY,CAAC;AACtC,OAAO,EAAC,mBAAmB,EAAC,MAAM,aAAa,CAAC;AAChD,OAAO,EAAO,IAAI,EAAC,MAAM,YAAY,CAAC;AAGtC,OAAO,EAAC,YAAY,EAAC,MAAM,YAAY,CAAC;AAExC;IAAuC,6CAAY;IAKjD,2BAAY,MAAoB,EAAU,SAAiC;QAA3E,YACE,kBAAM,MAAM,CAAC,SACd;QAFyC,eAAS,GAAT,SAAS,CAAwB;;IAE3E,CAAC;IANM,iCAAK,GAAZ;QACE,OAAO,IAAI,iBAAiB,CAAC,IAAI,uBAAM,IAAI,CAAC,SAAS,EAAE,CAAC;IAC1D,CAAC;IAMa,sBAAI,GAAlB,UAAmB,MAAoB,EAAE,KAAgB;QAChD,IAAA,qBAAM,EAAE,iBAAI,CAAU;QAC7B,IAAI,MAAM,CAAC,aAAa,KAAK,QAAQ,EAAE;YACrC,OAAO,IAAI,CAAC;SACb;QAED,IAAM,MAAM,GAAG,KAAK,CAAC,cAAc,CACjC,UAAC,UAAkC,EAAE,QAAQ,EAAE,OAAO;YACpD,IAAM,cAAc,GAAG,cAAc,CAAC,OAAO,CAAC,IAAI,KAAK,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC;YACnF,IAAI,cAAc,EAAE;gBAClB,IAAM,SAAS,GAAG,cAAc,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;gBAE7C,mFAAmF;gBACnF,uFAAuF;gBACvF,kFAAkF;gBAClF,IAAI,mBAAmB,CAAC,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE;oBAC9E,UAAU,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,QAAQ,CAAC;iBACvC;aACF;YACD,OAAO,UAAU,CAAC;QACpB,CAAC,EACD,EAA4B,CAC7B,CAAC;QAEF,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,MAAM,EAAE;YACxB,OAAO,IAAI,CAAC;SACb;QAED,OAAO,IAAI,iBAAiB,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IAC/C,CAAC;IAED,sBAAI,qCAAM;aAAV;YACE,OAAO,IAAI,CAAC,SAAS,CAAC;QACxB,CAAC;;;OAAA;IAED,0DAA0D;IACnD,oCAAQ,GAAf;QAAA,iBAkBC;QAjBC,IAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,UAAC,WAAW,EAAE,KAAK;YAC1D,IAAM,QAAQ,GAAG,KAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;YACvC,IAAM,GAAG,GAAG,QAAQ,CAAC,QAAQ,EAAE,EAAC,IAAI,EAAE,OAAO,EAAC,CAAC,CAAC;YAEhD,IAAI,QAAQ,KAAK,IAAI,EAAE;gBACrB,WAAW,CAAC,IAAI,CAAI,GAAG,cAAW,CAAC,CAAC;gBACpC,WAAW,CAAC,IAAI,CAAC,YAAU,GAAG,MAAG,CAAC,CAAC;aACpC;YACD,OAAO,WAAW,CAAC;QACrB,CAAC,EAAE,EAAE,CAAC,CAAC;QAEP,OAAO,OAAO,CAAC,MAAM,GAAG,CAAC;YACvB,CAAC,CAAC;gBACE,IAAI,EAAE,QAAQ;gBACd,IAAI,EAAE,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC;aAC3B;YACH,CAAC,CAAC,IAAI,CAAC;IACX,CAAC;IACH,wBAAC;AAAD,CAAC,AAhED,CAAuC,YAAY,GAgElD","sourcesContent":["import {isScaleChannel} from '../../channel';\nimport {FieldDef, vgField as fieldRef} from '../../fielddef';\nimport {isPathMark} from '../../mark';\nimport {hasContinuousDomain} from '../../scale';\nimport {Dict, keys} from '../../util';\nimport {VgFilterTransform} from '../../vega.schema';\nimport {UnitModel} from '../unit';\nimport {DataFlowNode} from './dataflow';\n\nexport class FilterInvalidNode extends DataFlowNode {\n  public clone() {\n    return new FilterInvalidNode(null, {...this.fieldDefs});\n  }\n\n  constructor(parent: DataFlowNode, private fieldDefs: Dict<FieldDef<string>>) {\n    super(parent);\n  }\n\n  public static make(parent: DataFlowNode, model: UnitModel): FilterInvalidNode {\n    const {config, mark} = model;\n    if (config.invalidValues !== 'filter') {\n      return null;\n    }\n\n    const filter = model.reduceFieldDef(\n      (aggregator: Dict<FieldDef<string>>, fieldDef, channel) => {\n        const scaleComponent = isScaleChannel(channel) && model.getScaleComponent(channel);\n        if (scaleComponent) {\n          const scaleType = scaleComponent.get('type');\n\n          // While discrete domain scales can handle invalid values, continuous scales can't.\n          // Thus, for non-path marks, we have to filter null for scales with continuous domains.\n          // (For path marks, we will use \"defined\" property and skip these values instead.)\n          if (hasContinuousDomain(scaleType) && !fieldDef.aggregate && !isPathMark(mark)) {\n            aggregator[fieldDef.field] = fieldDef;\n          }\n        }\n        return aggregator;\n      },\n      {} as Dict<FieldDef<string>>\n    );\n\n    if (!keys(filter).length) {\n      return null;\n    }\n\n    return new FilterInvalidNode(parent, filter);\n  }\n\n  get filter() {\n    return this.fieldDefs;\n  }\n\n  // create the VgTransforms for each of the filtered fields\n  public assemble(): VgFilterTransform {\n    const filters = keys(this.filter).reduce((vegaFilters, field) => {\n      const fieldDef = this.fieldDefs[field];\n      const ref = fieldRef(fieldDef, {expr: 'datum'});\n\n      if (fieldDef !== null) {\n        vegaFilters.push(`${ref} !== null`);\n        vegaFilters.push(`!isNaN(${ref})`);\n      }\n      return vegaFilters;\n    }, []);\n\n    return filters.length > 0\n      ? {\n          type: 'filter',\n          expr: filters.join(' && ')\n        }\n      : null;\n  }\n}\n"]}