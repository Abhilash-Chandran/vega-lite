{"version":3,"file":"project.js","sourceRoot":"","sources":["../../../../../src/compile/selection/transforms/project.ts"],"names":[],"mappings":"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","sourcesContent":["import {isArray} from 'vega-util';\nimport {ScaleChannel} from '../../../channel';\nimport * as log from '../../../log';\nimport {hasContinuousDomain} from '../../../scale';\nimport {isIntervalSelection, SelectionDef, SelectionInitArrayMapping, SelectionInitMapping} from '../../../selection';\nimport {Dict, keys} from '../../../util';\nimport {TimeUnitComponent, TimeUnitNode} from '../../data/timeunit';\nimport {ProjectSelectionComponent, SelectionComponent, TUPLE, TupleStoreType} from '../selection';\nimport scales from './scales';\nimport {TransformCompiler} from './transforms';\n\nexport const TUPLE_FIELDS = '_fields';\n\nconst project: TransformCompiler = {\n  has: (selDef: SelectionComponent | SelectionDef) => {\n    const def = selDef as SelectionDef;\n    return def.fields !== undefined || def.encodings !== undefined;\n  },\n\n  parse: (model, selDef, selCmpt) => {\n    const timeUnits: Dict<TimeUnitComponent> = {};\n    const f: Dict<ProjectSelectionComponent> = {};\n\n    // Selection component may already have a projection from the config. (Interval selection will have `encodings: ['x', 'y'].)\n    const proj = selCmpt.project || (selCmpt.project = []);\n    selCmpt.fields = {};\n\n    // TODO: find a possible channel mapping for these fields.\n    if (selDef.fields) {\n      proj.push(...selDef.fields.map<ProjectSelectionComponent>(field => ({field, type: 'E'})));\n    }\n\n    for (const channel of selDef.encodings || []) {\n      const fieldDef = model.fieldDef(channel);\n      if (fieldDef) {\n        let field = fieldDef.field;\n        if (fieldDef.timeUnit) {\n          field = model.vgField(channel);\n\n          // Construct TimeUnitComponents which will be combined into a\n          // TimeUnitNode. This node may need to be inserted into the\n          // dataflow if the selection is used across views that do not\n          // have these time units defined.\n          timeUnits[field] = {\n            as: field,\n            field: fieldDef.field,\n            timeUnit: fieldDef.timeUnit\n          };\n        }\n\n        // Prevent duplicate projections on the same field.\n        // TODO: what if the same field is bound to multiple channels (e.g., SPLOM diag).\n        if (!f[field]) {\n          // Determine whether the tuple will store enumerated or ranged values.\n          // Interval selections store ranges for continuous scales, and enumerations otherwise.\n          // Single/multi selections store ranges for binned fields, and enumerations otherwise.\n          let type: TupleStoreType = 'E';\n          if (selCmpt.type === 'interval') {\n            const scaleType = model.getScaleComponent(channel as ScaleChannel).get('type');\n            if (hasContinuousDomain(scaleType)) {\n              type = 'R';\n            }\n          } else if (fieldDef.bin) {\n            type = 'R-RE';\n          }\n\n          proj.push((f[field] = {field, channel, type}));\n        }\n\n        selCmpt.fields[channel] = field;\n      } else {\n        log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n      }\n    }\n\n    if (selDef.init) {\n      if (scales.has(selCmpt)) {\n        log.warn(log.message.NO_INIT_SCALE_BINDINGS);\n      } else {\n        function parseInit<T extends SelectionInitMapping | SelectionInitArrayMapping>(i: T): T['a'][] {\n          return proj.map(p => (i[p.channel] !== undefined ? i[p.channel] : i[p.field]));\n        }\n\n        if (isIntervalSelection(selDef)) {\n          selCmpt.init = parseInit(selDef.init);\n        } else {\n          const init = isArray(selDef.init) ? selDef.init : [selDef.init];\n          selCmpt.init = init.map(parseInit);\n        }\n      }\n    }\n\n    if (keys(timeUnits).length) {\n      selCmpt.timeUnit = new TimeUnitNode(null, timeUnits);\n    }\n  },\n\n  signals: (model, selCmpt, signals) => {\n    const name = selCmpt.name + TUPLE + TUPLE_FIELDS;\n    const hasSignal = signals.filter(s => s.name === name);\n    return hasSignal.length\n      ? signals\n      : signals.concat({\n          name,\n          value: selCmpt.project\n        });\n  }\n};\n\nexport default project;\n"]}