{"version":3,"file":"properties.test.js","sourceRoot":"","sources":["../../../../test/compile/scale/properties.test.ts"],"names":[],"mappings":"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","sourcesContent":["/* tslint:disable:quotemark */\n\nimport {assert} from 'chai';\n\nimport {Channel, NONPOSITION_SCALE_CHANNELS} from '../../../src/channel';\nimport {ScaleType} from '../../../src/scale';\n\nimport * as rules from '../../../src/compile/scale/properties';\nimport {AREA, BAR, LINE} from '../../../src/mark';\n\ndescribe('compile/scale', () => {\n  describe('nice', () => {\n    it('should return nice for x and y.', () => {\n      for (const c of ['x', 'y'] as Channel[]) {\n        assert.equal(rules.nice('linear', c, {type: 'quantitative'}), true);\n      }\n    });\n\n    it('should not return nice for binned x and y.', () => {\n      for (const c of ['x', 'y'] as Channel[]) {\n        assert.equal(rules.nice('linear', c, {type: 'quantitative', bin: true}), undefined);\n      }\n    });\n\n    it('should not return nice for temporal x and y.', () => {\n      for (const c of ['x', 'y'] as Channel[]) {\n        assert.equal(rules.nice('time', c, {type: 'temporal'}), undefined);\n      }\n    });\n  });\n\n  describe('padding', () => {\n    it('should be pointPadding for point scale if channel is x or y and padding is not specified.', () => {\n      for (const c of ['x', 'y'] as Channel[]) {\n        assert.equal(rules.padding(c, 'point', {pointPadding: 13}, undefined, undefined, undefined), 13);\n      }\n    });\n\n    it('should be continuousBandSize for linear x-scale of vertical bar.', () => {\n      assert.equal(\n        rules.padding(\n          'x',\n          'linear',\n          {},\n          {field: 'date', type: 'temporal'},\n          {type: 'bar', orient: 'vertical'},\n          {continuousBandSize: 13}\n        ),\n        13\n      );\n    });\n\n    it('should be undefined for linear x-scale for binned field of vertical bar.', () => {\n      assert.equal(\n        rules.padding(\n          'x',\n          'linear',\n          {},\n          {bin: true, field: 'date', type: 'temporal'},\n          {type: 'bar', orient: 'vertical'},\n          {continuousBandSize: 13}\n        ),\n        undefined\n      );\n    });\n\n    it('should be continuousBandSize for linear y-scale of horizontal bar.', () => {\n      assert.equal(\n        rules.padding(\n          'y',\n          'linear',\n          {},\n          {field: 'date', type: 'temporal'},\n          {type: 'bar', orient: 'horizontal'},\n          {continuousBandSize: 13}\n        ),\n        13\n      );\n    });\n  });\n\n  describe('paddingInner', () => {\n    it('should be undefined if padding is specified.', () => {\n      assert.equal(rules.paddingInner(10, 'x', {}), undefined);\n    });\n\n    it('should be bandPaddingInner if channel is x or y and padding is not specified.', () => {\n      assert.equal(rules.paddingInner(undefined, 'x', {bandPaddingInner: 15}), 15);\n      assert.equal(rules.paddingInner(undefined, 'y', {bandPaddingInner: 15}), 15);\n    });\n\n    it('should be undefined for non-xy channels.', () => {\n      for (const c of NONPOSITION_SCALE_CHANNELS) {\n        assert.equal(rules.paddingInner(undefined, c, {bandPaddingInner: 15}), undefined);\n      }\n    });\n  });\n\n  describe('paddingOuter', () => {\n    it('should be undefined if padding is specified.', () => {\n      for (const scaleType of ['point', 'band'] as ScaleType[]) {\n        assert.equal(rules.paddingOuter(10, 'x', scaleType, 0, {}), undefined);\n      }\n    });\n\n    it('should be config.scale.bandPaddingOuter for band scale if channel is x or y and padding is not specified and config.scale.bandPaddingOuter.', () => {\n      for (const c of ['x', 'y'] as Channel[]) {\n        assert.equal(rules.paddingOuter(undefined, c, 'band', 0, {bandPaddingOuter: 16}), 16);\n      }\n    });\n    it('should be paddingInner/2 for band scale if channel is x or y and padding is not specified and config.scale.bandPaddingOuter.', () => {\n      for (const c of ['x', 'y'] as Channel[]) {\n        assert.equal(rules.paddingOuter(undefined, c, 'band', 10, {}), 5);\n      }\n    });\n\n    it('should be undefined for non-xy channels.', () => {\n      for (const c of NONPOSITION_SCALE_CHANNELS) {\n        for (const scaleType of ['point', 'band'] as ScaleType[]) {\n          assert.equal(rules.paddingOuter(undefined, c, scaleType, 0, {}), undefined);\n        }\n      }\n    });\n  });\n\n  describe('reverse', () => {\n    it('should return true for a continuous scale with sort = \"descending\".', () => {\n      assert.isTrue(rules.reverse('linear', 'descending'));\n    });\n\n    it('should return false for a discrete scale with sort = \"descending\".', () => {\n      assert.isUndefined(rules.reverse('point', 'descending'));\n    });\n  });\n\n  describe('interpolate', () => {\n    it('should return hcl for continuous color scale', () => {\n      assert.equal(rules.interpolate('color', 'linear'), 'hcl');\n    });\n\n    it('should return undefined for discrete color scale', () => {\n      assert.isUndefined(rules.interpolate('color', 'sequential'));\n    });\n  });\n\n  describe('zero', () => {\n    it('should return true when mapping a quantitative field to x with scale.domain = \"unaggregated\"', () => {\n      assert(rules.zero('x', {field: 'a', type: 'quantitative'}, 'unaggregated', {type: 'point'}, 'linear'));\n    });\n\n    it('should return true when mapping a quantitative field to size', () => {\n      assert(rules.zero('size', {field: 'a', type: 'quantitative'}, undefined, {type: 'point'}, 'linear'));\n    });\n\n    it('should return false when mapping a ordinal field to size', () => {\n      assert(!rules.zero('size', {field: 'a', type: 'ordinal'}, undefined, {type: 'point'}, 'linear'));\n    });\n\n    it('should return true when mapping a non-binned quantitative field to x/y of point', () => {\n      for (const channel of ['x', 'y'] as Channel[]) {\n        assert(rules.zero(channel, {field: 'a', type: 'quantitative'}, undefined, {type: 'point'}, 'linear'));\n      }\n    });\n\n    it('should return false when mapping a quantitative field to dimension axis of bar, line, and area', () => {\n      for (const mark of [BAR, AREA, LINE]) {\n        assert.isFalse(\n          rules.zero('x', {field: 'a', type: 'quantitative'}, undefined, {type: mark, orient: 'vertical'}, 'linear')\n        );\n        assert.isFalse(\n          rules.zero('y', {field: 'a', type: 'quantitative'}, undefined, {type: mark, orient: 'horizontal'}, 'linear')\n        );\n      }\n    });\n\n    it('should return false when mapping a binned quantitative field to x/y', () => {\n      for (const channel of ['x', 'y'] as Channel[]) {\n        assert(\n          !rules.zero(channel, {bin: true, field: 'a', type: 'quantitative'}, undefined, {type: 'point'}, 'linear')\n        );\n      }\n    });\n\n    it('should return false when mapping a non-binned quantitative field with custom domain to x/y', () => {\n      for (const channel of ['x', 'y'] as Channel[]) {\n        assert(\n          !rules.zero(\n            channel,\n            {\n              bin: true,\n              field: 'a',\n              type: 'quantitative'\n            },\n            [3, 5],\n            {type: 'point'},\n            'linear'\n          )\n        );\n      }\n    });\n  });\n});\n"]}