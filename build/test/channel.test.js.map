{"version":3,"file":"channel.test.js","sourceRoot":"","sources":["../../test/channel.test.ts"],"names":[],"mappings":"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","sourcesContent":["import {assert} from 'chai';\nimport {\n  isScaleChannel,\n  rangeType,\n  SINGLE_DEF_CHANNELS,\n  supportMark,\n  X2,\n  XERROR,\n  XERROR2,\n  Y2,\n  YERROR,\n  YERROR2\n} from '../src/channel';\nimport {CHANNELS, NONPOSITION_SCALE_CHANNELS, SCALE_CHANNELS, UNIT_CHANNELS} from '../src/channel';\nimport {Encoding} from '../src/encoding';\nimport {CIRCLE, POINT, PRIMITIVE_MARKS, SQUARE, TICK} from '../src/mark';\nimport {without} from '../src/util';\n\ndescribe('channel', () => {\n  describe('UNIT_CHANNELS', () => {\n    it('should be CHANNELS without row and column', () => {\n      assert.deepEqual(UNIT_CHANNELS, without(CHANNELS, ['row', 'column']));\n    });\n  });\n\n  describe('SINGLE_DEF_CHANNELS', () => {\n    it('should be CHANNELS without detail and order', () => {\n      assert.deepEqual(SINGLE_DEF_CHANNELS, without(CHANNELS, ['detail', 'order']));\n    });\n  });\n\n  describe('SCALE_CHANNELS', () => {\n    it('should be UNIT_CHANNELS without X2, Y2, ORDER, DETAIL, TEXT, LABEL, TOOLTIP', () => {\n      assert.deepEqual(\n        SCALE_CHANNELS,\n        without(UNIT_CHANNELS, [\n          'x2',\n          'y2',\n          'xError',\n          'yError',\n          'xError2',\n          'yError2',\n          'latitude',\n          'longitude',\n          'latitude2',\n          'longitude2',\n          'order',\n          'detail',\n          'key',\n          'text',\n          'label',\n          'tooltip',\n          'href'\n        ])\n      );\n    });\n  });\n\n  describe('NONPOSITION_SCALE_CHANNELS', () => {\n    it('should be SCALE_CHANNELS without x, y, x2, y2', () => {\n      assert.deepEqual(NONPOSITION_SCALE_CHANNELS, without(SCALE_CHANNELS, ['x', 'y']));\n    });\n  });\n\n  describe('isScaleChannel', () => {\n    it('should return true for all scale channel', () => {\n      for (const channel of SCALE_CHANNELS) {\n        assert(isScaleChannel(channel));\n      }\n    });\n  });\n\n  describe('rangeType', () => {\n    it('should be defined for all channels (no error).', () => {\n      for (const c of CHANNELS) {\n        assert.doesNotThrow(() => {\n          rangeType(c);\n        });\n      }\n    });\n  });\n\n  describe('supportMark', () => {\n    it('should support x2 for circle, point, square and tick mark with binned data', () => {\n      const encoding: Encoding<string> = {\n        x: {\n          field: 'bin_start',\n          bin: 'binned',\n          type: 'quantitative',\n          axis: {\n            tickStep: 2\n          }\n        },\n        x2: {\n          field: 'bin_end',\n          type: 'quantitative'\n        },\n        y: {\n          field: 'count',\n          type: 'quantitative'\n        }\n      };\n      assert.isTrue(supportMark(encoding, X2, CIRCLE));\n      assert.isTrue(supportMark(encoding, X2, POINT));\n      assert.isTrue(supportMark(encoding, X2, SQUARE));\n      assert.isTrue(supportMark(encoding, X2, TICK));\n    });\n\n    it('should support y2 for circle, point, square and tick mark with binned data', () => {\n      const encoding: Encoding<string> = {\n        y: {\n          field: 'bin_start',\n          bin: 'binned',\n          type: 'quantitative',\n          axis: {\n            tickStep: 2\n          }\n        },\n        y2: {\n          field: 'bin_end',\n          type: 'quantitative'\n        },\n        x: {\n          field: 'count',\n          type: 'quantitative'\n        }\n      };\n      assert.isTrue(supportMark(encoding, Y2, CIRCLE));\n      assert.isTrue(supportMark(encoding, Y2, POINT));\n      assert.isTrue(supportMark(encoding, Y2, SQUARE));\n      assert.isTrue(supportMark(encoding, Y2, TICK));\n    });\n\n    it('should not support x2 for circle, point, square and tick mark without binned data', () => {\n      const encoding: Encoding<string> = {\n        x: {\n          field: 'bin_start',\n          type: 'quantitative',\n          axis: {\n            tickStep: 2\n          }\n        },\n        x2: {\n          field: 'bin_end',\n          type: 'quantitative'\n        },\n        y: {\n          field: 'count',\n          type: 'quantitative'\n        }\n      };\n      assert.isFalse(supportMark(encoding, X2, CIRCLE));\n      assert.isFalse(supportMark(encoding, X2, POINT));\n      assert.isFalse(supportMark(encoding, X2, SQUARE));\n      assert.isFalse(supportMark(encoding, X2, TICK));\n    });\n\n    it('should not support y2 for circle, point, square and tick mark with binned data', () => {\n      const encoding: Encoding<string> = {\n        y: {\n          field: 'bin_start',\n          type: 'quantitative',\n          axis: {\n            tickStep: 2\n          }\n        },\n        y2: {\n          field: 'bin_end',\n          type: 'quantitative'\n        },\n        x: {\n          field: 'count',\n          type: 'quantitative'\n        }\n      };\n      assert.isFalse(supportMark(encoding, Y2, CIRCLE));\n      assert.isFalse(supportMark(encoding, Y2, POINT));\n      assert.isFalse(supportMark(encoding, Y2, SQUARE));\n      assert.isFalse(supportMark(encoding, Y2, TICK));\n    });\n\n    it('should not support xError for all marks', () => {\n      const encoding: Encoding<string> = {\n        y: {\n          field: 'bin_start',\n          type: 'quantitative',\n          axis: {\n            tickStep: 2\n          }\n        },\n        x: {\n          field: 'count',\n          type: 'quantitative'\n        },\n        xError: {\n          field: 'count',\n          type: 'quantitative'\n        }\n      };\n\n      for (const m of PRIMITIVE_MARKS) {\n        assert.isFalse(supportMark(encoding, XERROR, m));\n      }\n    });\n\n    it('should not support xError2 for all marks', () => {\n      const encoding: Encoding<string> = {\n        y: {\n          field: 'bin_start',\n          type: 'quantitative',\n          axis: {\n            tickStep: 2\n          }\n        },\n        x: {\n          field: 'count',\n          type: 'quantitative'\n        },\n        xError2: {\n          field: 'count',\n          type: 'quantitative'\n        }\n      };\n\n      for (const m of PRIMITIVE_MARKS) {\n        assert.isFalse(supportMark(encoding, XERROR2, m));\n      }\n    });\n\n    it('should not support yError for all marks', () => {\n      const encoding: Encoding<string> = {\n        x: {\n          field: 'bin_start',\n          type: 'quantitative',\n          axis: {\n            tickStep: 2\n          }\n        },\n        y: {\n          field: 'count',\n          type: 'quantitative'\n        },\n        yError: {\n          field: 'count',\n          type: 'quantitative'\n        }\n      };\n\n      for (const m of PRIMITIVE_MARKS) {\n        assert.isFalse(supportMark(encoding, YERROR, m));\n      }\n    });\n\n    it('should not support yError2 for all marks', () => {\n      const encoding: Encoding<string> = {\n        x: {\n          field: 'bin_start',\n          type: 'quantitative',\n          axis: {\n            tickStep: 2\n          }\n        },\n        y: {\n          field: 'count',\n          type: 'quantitative'\n        },\n        yError2: {\n          field: 'count',\n          type: 'quantitative'\n        }\n      };\n\n      for (const m of PRIMITIVE_MARKS) {\n        assert.isFalse(supportMark(encoding, YERROR2, m));\n      }\n    });\n  });\n});\n"]}