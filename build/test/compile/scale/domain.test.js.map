{"version":3,"file":"domain.test.js","sourceRoot":"","sources":["../../../../test/compile/scale/domain.test.ts"],"names":[],"mappings":"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","sourcesContent":["/* tslint:disable:quotemark */\n\nimport {SignalRef} from 'vega';\nimport {ScaleChannel} from '../../../src/channel';\nimport {domainSort, mergeDomains, parseDomainForChannel} from '../../../src/compile/scale/domain';\nimport {parseScaleCore} from '../../../src/compile/scale/parse';\nimport {UnitModel} from '../../../src/compile/unit';\nimport {MAIN} from '../../../src/data';\nimport {PositionFieldDef} from '../../../src/fielddef';\nimport * as log from '../../../src/log';\nimport {ScaleType} from '../../../src/scale';\nimport {EncodingSortField} from '../../../src/sort';\nimport {parseUnitModel} from '../../util';\n\ndescribe('compile/scale', () => {\n  describe('parseDomainForChannel()', () => {\n    function testParseDomainForChannel(model: UnitModel, channel: ScaleChannel) {\n      // Cannot parseDomain before parseScaleCore\n      parseScaleCore(model);\n      return parseDomainForChannel(model, channel);\n    }\n\n    it('should have correct domain with x and x2 channel', () => {\n      const model = parseUnitModel({\n        mark: 'bar',\n        encoding: {\n          x: {field: 'a', type: 'quantitative'},\n          x2: {field: 'b', type: 'quantitative'},\n          y: {field: 'c', type: 'quantitative'},\n          y2: {field: 'd', type: 'quantitative'}\n        }\n      });\n\n      const xDomain = testParseDomainForChannel(model, 'x');\n      expect(xDomain).toEqual([{data: 'main', field: 'a'}, {data: 'main', field: 'b'}]);\n\n      const yDomain = testParseDomainForChannel(model, 'y');\n      expect(yDomain).toEqual([{data: 'main', field: 'c'}, {data: 'main', field: 'd'}]);\n    });\n\n    it('should have correct domain for color', () => {\n      const model = parseUnitModel({\n        mark: 'bar',\n        encoding: {\n          color: {field: 'a', type: 'quantitative'}\n        }\n      });\n\n      const xDomain = testParseDomainForChannel(model, 'color');\n      expect(xDomain).toEqual([{data: 'main', field: 'a'}]);\n    });\n\n    it('should have correct domain for color ConditionField', () => {\n      const model = parseUnitModel({\n        mark: 'bar',\n        encoding: {\n          color: {\n            condition: {selection: 'sel', field: 'a', type: 'quantitative'}\n          }\n        }\n      });\n\n      const xDomain = testParseDomainForChannel(model, 'color');\n      expect(xDomain).toEqual([{data: 'main', field: 'a'}]);\n    });\n\n    it('should return domain for stack', () => {\n      const model = parseUnitModel({\n        mark: 'bar',\n        encoding: {\n          y: {\n            aggregate: 'sum',\n            field: 'origin',\n            type: 'quantitative'\n          },\n          x: {field: 'x', type: 'ordinal'},\n          color: {field: 'color', type: 'ordinal'}\n        }\n      });\n\n      expect(testParseDomainForChannel(model, 'y')).toEqual([\n        {\n          data: 'main',\n          field: 'sum_origin_start'\n        },\n        {\n          data: 'main',\n          field: 'sum_origin_end'\n        }\n      ]);\n    });\n\n    it('should return normalize domain for stack if specified', () => {\n      const model = parseUnitModel({\n        mark: 'bar',\n        encoding: {\n          y: {\n            aggregate: 'sum',\n            field: 'origin',\n            type: 'quantitative'\n          },\n          x: {field: 'x', type: 'ordinal'},\n          color: {field: 'color', type: 'ordinal'}\n        },\n        config: {\n          stack: 'normalize'\n        }\n      });\n\n      expect(testParseDomainForChannel(model, 'y')).toEqual([[0, 1]]);\n    });\n\n    describe('for quantitative', () => {\n      it(\n        'should return the right domain for binned Q',\n        log.wrap(localLogger => {\n          const fieldDef: PositionFieldDef<string> = {\n            bin: {maxbins: 15},\n            field: 'origin',\n            scale: {domain: 'unaggregated'},\n            type: 'quantitative'\n          };\n          const model = parseUnitModel({\n            mark: 'point',\n            encoding: {\n              y: fieldDef\n            }\n          });\n          const domain = testParseDomainForChannel(model, 'y')[0] as SignalRef;\n          expect(domain.signal).toEqual('[bin_maxbins_15_origin_bins.start, bin_maxbins_15_origin_bins.stop]');\n\n          expect(localLogger.warns[0]).toEqual(log.message.unaggregateDomainHasNoEffectForRawField(fieldDef));\n        })\n      );\n\n      it('should return the unaggregated domain if requested for non-bin, non-sum Q', () => {\n        const model = parseUnitModel({\n          mark: 'point',\n          encoding: {\n            y: {\n              aggregate: 'mean',\n              field: 'acceleration',\n              scale: {domain: 'unaggregated'},\n              type: 'quantitative'\n            }\n          }\n        });\n\n        expect(testParseDomainForChannel(model, 'y')).toEqual([\n          {\n            data: MAIN,\n            field: 'min_acceleration'\n          },\n          {\n            data: MAIN,\n            field: 'max_acceleration'\n          }\n        ]);\n      });\n\n      it(\n        'should return the aggregated domain for sum Q',\n        log.wrap(localLogger => {\n          const model = parseUnitModel({\n            mark: 'point',\n            encoding: {\n              y: {\n                aggregate: 'sum',\n                field: 'origin',\n                scale: {domain: 'unaggregated'},\n                type: 'quantitative'\n              }\n            }\n          });\n          testParseDomainForChannel(model, 'y');\n          expect(localLogger.warns[0]).toEqual(log.message.unaggregateDomainWithNonSharedDomainOp('sum'));\n        })\n      );\n\n      it('should return the right custom domain', () => {\n        const model = parseUnitModel({\n          mark: 'point',\n          encoding: {\n            y: {\n              field: 'horsepower',\n              type: 'quantitative',\n              scale: {domain: [0, 200]}\n            }\n          }\n        });\n        const _domain = testParseDomainForChannel(model, 'y');\n\n        expect(_domain).toEqual([[0, 200]]);\n      });\n\n      it(\n        'should follow the custom domain despite bin',\n        log.wrap(localLogger => {\n          const model = parseUnitModel({\n            mark: 'point',\n            encoding: {\n              y: {\n                field: 'origin',\n                type: 'quantitative',\n                scale: {domain: [0, 200]},\n                bin: {maxbins: 15}\n              }\n            }\n          });\n          const _domain = testParseDomainForChannel(model, 'y');\n\n          expect(_domain).toEqual([[0, 200]]);\n        })\n      );\n\n      it('should return the aggregated domain if we do not override it', () => {\n        const model = parseUnitModel({\n          mark: 'point',\n          encoding: {\n            y: {\n              aggregate: 'min',\n              field: 'origin',\n              type: 'quantitative'\n            }\n          }\n        });\n\n        expect(testParseDomainForChannel(model, 'y')).toEqual([\n          {\n            data: 'main',\n            field: 'min_origin'\n          }\n        ]);\n      });\n\n      it('should use the aggregated data for domain if specified in config', () => {\n        const model = parseUnitModel({\n          mark: 'point',\n          encoding: {\n            y: {\n              aggregate: 'min',\n              field: 'acceleration',\n              type: 'quantitative'\n            }\n          },\n          config: {\n            scale: {\n              useUnaggregatedDomain: true\n            }\n          }\n        });\n\n        expect(testParseDomainForChannel(model, 'y')).toEqual([\n          {\n            data: MAIN,\n            field: 'min_acceleration'\n          },\n          {\n            data: MAIN,\n            field: 'max_acceleration'\n          }\n        ]);\n      });\n    });\n\n    describe('for time', () => {\n      it('should return the correct domain for month T', () => {\n        const model = parseUnitModel({\n          mark: 'point',\n          encoding: {\n            y: {\n              field: 'origin',\n              type: 'temporal',\n              timeUnit: 'month'\n            }\n          }\n        });\n        const _domain = testParseDomainForChannel(model, 'y');\n        expect(_domain).toEqual([{data: 'main', field: 'month_origin'}]);\n      });\n\n      it('should return the correct domain for month O', () => {\n        const model = parseUnitModel({\n          mark: 'point',\n          encoding: {\n            y: {\n              field: 'origin',\n              type: 'ordinal',\n              timeUnit: 'month'\n            }\n          }\n        });\n        const _domain = testParseDomainForChannel(model, 'y');\n        expect(_domain).toEqual([{data: 'main', field: 'month_origin', sort: true}]);\n      });\n\n      it('should return the correct domain for yearmonth T', () => {\n        const model = parseUnitModel({\n          mark: 'point',\n          encoding: {\n            y: {\n              field: 'origin',\n              type: 'temporal',\n              timeUnit: 'yearmonth'\n            }\n          }\n        });\n        const _domain = testParseDomainForChannel(model, 'y');\n\n        expect(_domain).toEqual([{data: 'main', field: 'yearmonth_origin'}]);\n      });\n\n      it('should return the correct domain for month O when specify sort', () => {\n        const sortDef: EncodingSortField<string> = {op: 'mean', field: 'precipitation', order: 'descending'};\n        const model = parseUnitModel({\n          mark: 'bar',\n          encoding: {\n            x: {\n              timeUnit: 'month',\n              field: 'date',\n              type: 'ordinal',\n              sort: sortDef\n            },\n            y: {\n              aggregate: 'mean',\n              field: 'precipitation',\n              type: 'quantitative'\n            }\n          }\n        });\n        const _domain = testParseDomainForChannel(model, 'x');\n\n        expect(_domain).toEqual([\n          {\n            data: 'raw',\n            field: 'month_date',\n            sort: sortDef\n          }\n        ]);\n      });\n\n      it('should return the correct domain for month O when specify sort does not have op', () => {\n        const sortDef: EncodingSortField<string> = {field: 'precipitation', order: 'descending'};\n        const model = parseUnitModel({\n          mark: 'bar',\n          encoding: {\n            x: {\n              timeUnit: 'month',\n              field: 'date',\n              type: 'ordinal',\n              sort: sortDef\n            },\n            y: {\n              aggregate: 'mean',\n              field: 'precipitation',\n              type: 'quantitative'\n            }\n          }\n        });\n        const _domain = testParseDomainForChannel(model, 'x');\n\n        expect(_domain).toEqual([\n          {\n            data: 'raw',\n            field: 'month_date',\n            sort: {...sortDef, op: 'mean'}\n          }\n        ]);\n      });\n\n      it('should return the correct domain for month O when the field is sorted by another encoding', () => {\n        const model = parseUnitModel({\n          mark: 'bar',\n          encoding: {\n            x: {\n              timeUnit: 'month',\n              field: 'date',\n              type: 'ordinal',\n              sort: {encoding: 'y'}\n            },\n            y: {\n              aggregate: 'median',\n              field: 'precipitation',\n              type: 'quantitative'\n            }\n          }\n        });\n        const _domain = testParseDomainForChannel(model, 'x');\n\n        expect(_domain).toEqual([\n          {\n            data: 'raw',\n            field: 'month_date',\n            sort: {op: 'median', field: 'precipitation'}\n          }\n        ]);\n      });\n\n      it('should return the correct domain for month O when specify sort does not have op and the plot is stacked', () => {\n        const sortDef: EncodingSortField<string> = {field: 'precipitation', order: 'descending'};\n        const model = parseUnitModel({\n          mark: 'bar',\n          encoding: {\n            x: {\n              timeUnit: 'month',\n              field: 'date',\n              type: 'ordinal',\n              sort: sortDef\n            },\n            y: {\n              aggregate: 'sum',\n              field: 'precipitation',\n              type: 'quantitative'\n            },\n            color: {\n              field: 'weather_type',\n              type: 'nominal'\n            }\n          }\n        });\n        const _domain = testParseDomainForChannel(model, 'x');\n\n        expect(_domain).toEqual([\n          {\n            data: 'raw',\n            field: 'month_date',\n            sort: {...sortDef, op: 'sum'}\n          }\n        ]);\n      });\n\n      it('should return the right custom domain with DateTime objects', () => {\n        const model = parseUnitModel({\n          mark: 'point',\n          encoding: {\n            y: {\n              field: 'year',\n              type: 'temporal',\n              scale: {domain: [{year: 1970}, {year: 1980}]}\n            }\n          }\n        });\n        const _domain = testParseDomainForChannel(model, 'y');\n\n        expect(_domain).toEqual([\n          {signal: '{data: datetime(1970, 0, 1, 0, 0, 0, 0)}'},\n          {signal: '{data: datetime(1980, 0, 1, 0, 0, 0, 0)}'}\n        ]);\n      });\n\n      it('should return the right custom domain with date strings', () => {\n        const model = parseUnitModel({\n          mark: 'point',\n          encoding: {\n            y: {\n              field: 'year',\n              type: 'temporal',\n              scale: {domain: ['Jan 1, 2007', 'Jan 1, 2009']}\n            }\n          }\n        });\n        const _domain = testParseDomainForChannel(model, 'y');\n\n        expect(_domain).toEqual([\n          {signal: `{data: datetime(\"Jan 1, 2007\")}`},\n          {signal: `{data: datetime(\"Jan 1, 2009\")}`}\n        ]);\n      });\n    });\n\n    describe('for ordinal', () => {\n      it('should have correct domain for binned ordinal color', () => {\n        const model = parseUnitModel({\n          mark: 'bar',\n          encoding: {\n            color: {field: 'a', bin: true, type: 'ordinal'}\n          }\n        });\n\n        const xDomain = testParseDomainForChannel(model, 'color');\n        expect(xDomain).toEqual([\n          {data: 'main', field: 'bin_maxbins_6_a_range', sort: {field: 'bin_maxbins_6_a', op: 'min'}}\n        ]);\n      });\n    });\n\n    describe('for nominal', () => {\n      it('should return correct domain with the provided sort property', () => {\n        const sortDef: EncodingSortField<string> = {op: 'min' as 'min', field: 'Acceleration'};\n        const model = parseUnitModel({\n          mark: 'point',\n          encoding: {\n            y: {field: 'origin', type: 'nominal', sort: sortDef}\n          }\n        });\n        expect(testParseDomainForChannel(model, 'y')).toEqual([\n          {\n            data: 'raw',\n            field: 'origin',\n            sort: sortDef\n          }\n        ]);\n      });\n\n      it('should return correct domain with the provided sort property with order property', () => {\n        const sortDef: EncodingSortField<string> = {op: 'min', field: 'Acceleration', order: 'descending'};\n        const model = parseUnitModel({\n          mark: 'point',\n          encoding: {\n            y: {field: 'origin', type: 'nominal', sort: sortDef}\n          }\n        });\n\n        expect(testParseDomainForChannel(model, 'y')).toEqual([\n          {\n            data: 'raw',\n            field: 'origin',\n            sort: sortDef\n          }\n        ]);\n      });\n\n      it('should return correct domain without sort if sort is not provided', () => {\n        const model = parseUnitModel({\n          mark: 'point',\n          encoding: {\n            y: {field: 'origin', type: 'nominal'}\n          }\n        });\n\n        expect(testParseDomainForChannel(model, 'y')).toEqual([\n          {\n            data: 'main',\n            field: 'origin',\n            sort: true\n          }\n        ]);\n      });\n    });\n  });\n\n  describe('mergeDomains()', () => {\n    it('should merge the same domains', () => {\n      const domain = mergeDomains([\n        {\n          data: 'foo',\n          field: 'a',\n          sort: {field: 'b', op: 'mean'}\n        },\n        {\n          data: 'foo',\n          field: 'a',\n          sort: {field: 'b', op: 'mean'}\n        }\n      ]);\n\n      expect(domain).toEqual({\n        data: 'foo',\n        field: 'a',\n        sort: {field: 'b', op: 'mean'}\n      });\n    });\n\n    it('should drop field if op is count', () => {\n      const domain = mergeDomains([\n        {\n          data: 'foo',\n          field: 'a',\n          sort: {op: 'count', field: 'b'}\n        }\n      ]);\n\n      expect(domain).toEqual({\n        data: 'foo',\n        field: 'a',\n        sort: {op: 'count'}\n      });\n    });\n\n    it('should sort the output domain if one domain is sorted', () => {\n      const domain = mergeDomains([\n        {\n          data: 'foo',\n          field: 'a'\n        },\n        {\n          data: 'foo',\n          field: 'a',\n          sort: {field: 'b', op: 'mean', order: 'descending'}\n        }\n      ]);\n\n      expect(domain).toEqual({\n        data: 'foo',\n        field: 'a',\n        sort: {field: 'b', op: 'mean', order: 'descending'}\n      });\n    });\n\n    it('should sort the output domain if one domain is sorted with true', () => {\n      const domain = mergeDomains([\n        {\n          data: 'foo',\n          field: 'a',\n          sort: true\n        },\n        {\n          data: 'foo',\n          field: 'b'\n        }\n      ]);\n\n      expect(domain).toEqual({\n        data: 'foo',\n        fields: ['a', 'b'],\n        sort: true\n      });\n    });\n\n    it('should not sort if no domain is sorted', () => {\n      const domain = mergeDomains([\n        {\n          data: 'foo',\n          field: 'a'\n        },\n        {\n          data: 'foo',\n          field: 'b'\n        }\n      ]);\n\n      expect(domain).toEqual({\n        data: 'foo',\n        fields: ['a', 'b']\n      });\n    });\n\n    it('should ignore order ascending as it is the default', () => {\n      const domain = mergeDomains([\n        {\n          data: 'foo',\n          field: 'a',\n          sort: {field: 'b', op: 'mean', order: 'ascending'}\n        },\n        {\n          data: 'foo',\n          field: 'a',\n          sort: {field: 'b', op: 'mean'}\n        }\n      ]);\n\n      expect(domain).toEqual({\n        data: 'foo',\n        field: 'a',\n        sort: {field: 'b', op: 'mean'}\n      });\n    });\n\n    it('should merge domains with the same data', () => {\n      const domain = mergeDomains([\n        {\n          data: 'foo',\n          field: 'a'\n        },\n        {\n          data: 'foo',\n          field: 'a'\n        }\n      ]);\n\n      expect(domain).toEqual({\n        data: 'foo',\n        field: 'a'\n      });\n    });\n\n    it('should merge domains with the same data source', () => {\n      const domain = mergeDomains([\n        {\n          data: 'foo',\n          field: 'a'\n        },\n        {\n          data: 'foo',\n          field: 'b'\n        }\n      ]);\n\n      expect(domain).toEqual({\n        data: 'foo',\n        fields: ['a', 'b']\n      });\n    });\n\n    it('should merge domains with different data source', () => {\n      const domain = mergeDomains([\n        {\n          data: 'foo',\n          field: 'a',\n          sort: true\n        },\n        {\n          data: 'bar',\n          field: 'a',\n          sort: true\n        }\n      ]);\n\n      expect(domain).toEqual({\n        fields: [\n          {\n            data: 'foo',\n            field: 'a'\n          },\n          {\n            data: 'bar',\n            field: 'a'\n          }\n        ],\n        sort: true\n      });\n    });\n\n    it('should merge domains with different data and sort', () => {\n      const domain = mergeDomains([\n        {\n          data: 'foo',\n          field: 'a',\n          sort: {\n            op: 'count'\n          }\n        },\n        {\n          data: 'bar',\n          field: 'a'\n        }\n      ]);\n\n      expect(domain).toEqual({\n        fields: [\n          {\n            data: 'foo',\n            field: 'a'\n          },\n          {\n            data: 'bar',\n            field: 'a'\n          }\n        ],\n        sort: {\n          op: 'count'\n        }\n      });\n    });\n\n    it('should merge domains with the same and different data', () => {\n      const domain = mergeDomains([\n        {\n          data: 'foo',\n          field: 'a'\n        },\n        {\n          data: 'foo',\n          field: 'b'\n        },\n        {\n          data: 'bar',\n          field: 'a'\n        }\n      ]);\n\n      expect(domain).toEqual({\n        fields: [\n          {\n            data: 'foo',\n            field: 'a'\n          },\n          {\n            data: 'foo',\n            field: 'b'\n          },\n          {\n            data: 'bar',\n            field: 'a'\n          }\n        ]\n      });\n    });\n\n    it('should merge signal domains', () => {\n      const domain = mergeDomains([\n        {\n          signal: 'foo'\n        },\n        {\n          data: 'bar',\n          field: 'a'\n        }\n      ]);\n\n      expect(domain).toEqual({\n        fields: [\n          {\n            signal: 'foo'\n          },\n          {\n            data: 'bar',\n            field: 'a'\n          }\n        ]\n      });\n    });\n\n    it(\n      'should warn if sorts conflict',\n      log.wrap(localLogger => {\n        const domain = mergeDomains([\n          {\n            data: 'foo',\n            field: 'a',\n            sort: {\n              op: 'count'\n            }\n          },\n          {\n            data: 'foo',\n            field: 'b',\n            sort: true\n          }\n        ]);\n\n        expect(domain).toEqual({\n          data: 'foo',\n          fields: ['a', 'b'],\n          sort: true\n        });\n\n        expect(localLogger.warns[0]).toEqual(log.message.MORE_THAN_ONE_SORT);\n      })\n    );\n\n    it(\n      'should warn if sorts conflict even if we do not union',\n      log.wrap(localLogger => {\n        const domain = mergeDomains([\n          {\n            data: 'foo',\n            field: 'a',\n            sort: {\n              op: 'count'\n            }\n          },\n          {\n            data: 'foo',\n            field: 'a',\n            sort: true\n          }\n        ]);\n\n        expect(domain).toEqual({\n          data: 'foo',\n          field: 'a',\n          sort: true\n        });\n\n        expect(localLogger.warns[0]).toEqual(log.message.MORE_THAN_ONE_SORT);\n      })\n    );\n\n    it(\n      'should warn if we had to drop complex sort',\n      log.wrap(localLogger => {\n        const domain = mergeDomains([\n          {\n            data: 'foo',\n            field: 'a',\n            sort: {\n              op: 'mean',\n              field: 'c'\n            }\n          },\n          {\n            data: 'foo',\n            field: 'b'\n          }\n        ]);\n\n        expect(domain).toEqual({\n          data: 'foo',\n          fields: ['a', 'b'],\n          sort: true\n        });\n\n        expect(localLogger.warns[0]).toEqual(\n          log.message.domainSortDropped({\n            op: 'mean',\n            field: 'c'\n          })\n        );\n      })\n    );\n\n    it('should not sort explicit domains', () => {\n      const domain = mergeDomains([[1, 2, 3, 4], [3, 4, 5, 6]]);\n\n      expect(domain).toEqual({\n        fields: [[1, 2, 3, 4], [3, 4, 5, 6]]\n      });\n    });\n  });\n\n  describe('domainSort()', () => {\n    it('should return undefined for continuous domain', () => {\n      const model = parseUnitModel({\n        mark: 'point',\n        encoding: {\n          x: {field: 'a', type: 'quantitative'}\n        }\n      });\n      const sort = domainSort(model, 'x', ScaleType.LINEAR);\n      expect(sort).toEqual(undefined);\n    });\n\n    it('should return true by default for discrete domain', () => {\n      const model = parseUnitModel({\n        mark: 'point',\n        encoding: {\n          x: {field: 'a', type: 'ordinal'}\n        }\n      });\n      const sort = domainSort(model, 'x', ScaleType.ORDINAL);\n      expect(sort).toEqual(true);\n    });\n\n    it('should return true for ascending', () => {\n      const model = parseUnitModel({\n        mark: 'point',\n        encoding: {\n          x: {field: 'a', type: 'quantitative', sort: 'ascending'}\n        }\n      });\n      const sort = domainSort(model, 'x', ScaleType.ORDINAL);\n      expect(sort).toEqual(true);\n    });\n\n    it('should return undefined if sort = null', () => {\n      const model = parseUnitModel({\n        mark: 'bar',\n        encoding: {\n          x: {field: 'a', type: 'quantitative', sort: null}\n        }\n      });\n      const sort = domainSort(model, 'x', ScaleType.ORDINAL);\n      expect(sort).toEqual(undefined);\n    });\n\n    it('should return normal sort spec if specified and aggregration is not count', () => {\n      const model = parseUnitModel({\n        mark: 'bar',\n        encoding: {\n          x: {field: 'a', type: 'nominal', sort: {op: 'sum', field: 'y'}},\n          y: {field: 'b', aggregate: 'sum', type: 'quantitative'}\n        }\n      });\n      const sort = domainSort(model, 'x', ScaleType.ORDINAL);\n      expect(sort).toEqual({op: 'sum', field: 'y'});\n    });\n\n    it('should return normal sort spec if aggregration is count and field not specified', () => {\n      const model = parseUnitModel({\n        mark: 'bar',\n        encoding: {\n          x: {field: 'a', type: 'nominal', sort: {op: 'count'}},\n          y: {field: 'b', aggregate: 'sum', type: 'quantitative'}\n        }\n      });\n      const sort = domainSort(model, 'x', ScaleType.ORDINAL);\n      expect(sort).toEqual({op: 'count'});\n    });\n\n    it('should return true if sort is not specified', () => {\n      const model = parseUnitModel({\n        mark: 'bar',\n        encoding: {\n          x: {field: 'a', type: 'nominal'},\n          y: {field: 'b', aggregate: 'sum', type: 'quantitative'}\n        }\n      });\n      const sort = domainSort(model, 'x', ScaleType.ORDINAL);\n      expect(sort).toEqual(true);\n    });\n\n    it('should return undefined if sort is specified', () => {\n      const model = parseUnitModel({\n        mark: 'bar',\n        encoding: {\n          x: {field: 'a', type: 'nominal', sort: 'descending'},\n          y: {field: 'b', aggregate: 'sum', type: 'quantitative'}\n        }\n      });\n      expect(domainSort(model, 'x', ScaleType.ORDINAL)).toEqual({\n        op: 'min',\n        field: 'a',\n        order: 'descending'\n      });\n    });\n\n    it('should return sort spec using derived sort index', () => {\n      const model = parseUnitModel({\n        mark: 'bar',\n        encoding: {\n          x: {field: 'a', type: 'ordinal', sort: ['B', 'A', 'C']},\n          y: {field: 'b', type: 'quantitative'}\n        }\n      });\n      expect(domainSort(model, 'x', ScaleType.ORDINAL)).toEqual({\n        op: 'min',\n        field: 'x_a_sort_index',\n        order: 'ascending'\n      });\n    });\n\n    it('should return sort with flattened field access', () => {\n      const model = parseUnitModel({\n        mark: 'bar',\n        encoding: {\n          x: {field: 'a', type: 'ordinal', sort: {field: 'foo.bar', op: 'mean'}}\n        }\n      });\n      expect(domainSort(model, 'x', ScaleType.ORDINAL)).toEqual({op: 'mean', field: 'foo\\\\.bar'});\n    });\n  });\n});\n"]}