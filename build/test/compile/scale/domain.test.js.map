{"version":3,"file":"domain.test.js","sourceRoot":"","sources":["../../../../test/compile/scale/domain.test.ts"],"names":[],"mappings":"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","sourcesContent":["/* tslint:disable:quotemark */\n\nimport {assert} from 'chai';\nimport {ScaleChannel} from '../../../src/channel';\nimport {domainSort, mergeDomains, parseDomainForChannel} from '../../../src/compile/scale/domain';\nimport {parseScaleCore} from '../../../src/compile/scale/parse';\nimport {UnitModel} from '../../../src/compile/unit';\nimport {MAIN} from '../../../src/data';\nimport {PositionFieldDef} from '../../../src/fielddef';\nimport * as log from '../../../src/log';\nimport {ScaleType} from '../../../src/scale';\nimport {EncodingSortField} from '../../../src/sort';\nimport {VgDomain} from '../../../src/vega.schema';\nimport {parseUnitModel} from '../../util';\n\ndescribe('compile/scale', () => {\n  describe('parseDomainForChannel()', () => {\n    function testParseDomainForChannel(model: UnitModel, channel: ScaleChannel) {\n      // Cannot parseDomain before parseScaleCore\n      parseScaleCore(model);\n      return parseDomainForChannel(model, channel);\n    }\n\n    it('should have correct domain with x and x2 channel', () => {\n      const model = parseUnitModel({\n        mark: 'bar',\n        encoding: {\n          x: {field: 'a', type: 'quantitative'},\n          x2: {field: 'b', type: 'quantitative'},\n          y: {field: 'c', type: 'quantitative'},\n          y2: {field: 'd', type: 'quantitative'}\n        }\n      });\n\n      const xDomain = testParseDomainForChannel(model, 'x');\n      assert.deepEqual(xDomain, [{data: 'main', field: 'a'}, {data: 'main', field: 'b'}]);\n\n      const yDomain = testParseDomainForChannel(model, 'y');\n      assert.deepEqual(yDomain, [{data: 'main', field: 'c'}, {data: 'main', field: 'd'}]);\n    });\n\n    it('should have correct domain for color', () => {\n      const model = parseUnitModel({\n        mark: 'bar',\n        encoding: {\n          color: {field: 'a', type: 'quantitative'}\n        }\n      });\n\n      const xDomain = testParseDomainForChannel(model, 'color');\n      assert.deepEqual(xDomain, [{data: 'main', field: 'a'}]);\n    });\n\n    it('should have correct domain for color ConditionField', () => {\n      const model = parseUnitModel({\n        mark: 'bar',\n        encoding: {\n          color: {\n            condition: {selection: 'sel', field: 'a', type: 'quantitative'}\n          }\n        }\n      });\n\n      const xDomain = testParseDomainForChannel(model, 'color');\n      assert.deepEqual(xDomain, [{data: 'main', field: 'a'}]);\n    });\n\n    it('should return domain for stack', () => {\n      const model = parseUnitModel({\n        mark: 'bar',\n        encoding: {\n          y: {\n            aggregate: 'sum',\n            field: 'origin',\n            type: 'quantitative'\n          },\n          x: {field: 'x', type: 'ordinal'},\n          color: {field: 'color', type: 'ordinal'}\n        }\n      });\n\n      assert.deepEqual(testParseDomainForChannel(model, 'y'), [\n        {\n          data: 'main',\n          field: 'sum_origin_start'\n        },\n        {\n          data: 'main',\n          field: 'sum_origin_end'\n        }\n      ]);\n    });\n\n    it('should return normalize domain for stack if specified', () => {\n      const model = parseUnitModel({\n        mark: 'bar',\n        encoding: {\n          y: {\n            aggregate: 'sum',\n            field: 'origin',\n            type: 'quantitative'\n          },\n          x: {field: 'x', type: 'ordinal'},\n          color: {field: 'color', type: 'ordinal'}\n        },\n        config: {\n          stack: 'normalize'\n        }\n      });\n\n      assert.deepEqual(testParseDomainForChannel(model, 'y'), [[0, 1]]);\n    });\n\n    describe('for quantitative', () => {\n      it(\n        'should return the right domain for binned Q',\n        log.wrap(localLogger => {\n          const fieldDef: PositionFieldDef<string> = {\n            bin: {maxbins: 15},\n            field: 'origin',\n            scale: {domain: 'unaggregated'},\n            type: 'quantitative'\n          };\n          const model = parseUnitModel({\n            mark: 'point',\n            encoding: {\n              y: fieldDef\n            }\n          });\n\n          assert.deepEqual(testParseDomainForChannel(model, 'y'), [\n            {\n              data: 'main',\n              field: 'bin_maxbins_15_origin'\n            },\n            {\n              data: 'main',\n              field: 'bin_maxbins_15_origin_end'\n            }\n          ]);\n\n          assert.equal(localLogger.warns[0], log.message.unaggregateDomainHasNoEffectForRawField(fieldDef));\n        })\n      );\n\n      it(\n        'should follow the custom bin.extent for binned Q',\n        log.wrap(localLogger => {\n          const model = parseUnitModel({\n            mark: 'point',\n            encoding: {\n              y: {\n                field: 'origin',\n                type: 'quantitative',\n                bin: {maxbins: 15, extent: [0, 100]}\n              }\n            }\n          });\n          const _domain = testParseDomainForChannel(model, 'y');\n\n          assert.deepEqual(_domain, [[0, 100]]);\n        })\n      );\n\n      it('should return the unaggregated domain if requested for non-bin, non-sum Q', () => {\n        const model = parseUnitModel({\n          mark: 'point',\n          encoding: {\n            y: {\n              aggregate: 'mean',\n              field: 'acceleration',\n              scale: {domain: 'unaggregated'},\n              type: 'quantitative'\n            }\n          }\n        });\n\n        assert.deepEqual(testParseDomainForChannel(model, 'y'), [\n          {\n            data: MAIN,\n            field: 'min_acceleration'\n          },\n          {\n            data: MAIN,\n            field: 'max_acceleration'\n          }\n        ]);\n      });\n\n      it(\n        'should return the aggregated domain for sum Q',\n        log.wrap(localLogger => {\n          const model = parseUnitModel({\n            mark: 'point',\n            encoding: {\n              y: {\n                aggregate: 'sum',\n                field: 'origin',\n                scale: {domain: 'unaggregated'},\n                type: 'quantitative'\n              }\n            }\n          });\n          testParseDomainForChannel(model, 'y');\n          assert.equal(localLogger.warns[0], log.message.unaggregateDomainWithNonSharedDomainOp('sum'));\n        })\n      );\n\n      it('should return the right custom domain', () => {\n        const model = parseUnitModel({\n          mark: 'point',\n          encoding: {\n            y: {\n              field: 'horsepower',\n              type: 'quantitative',\n              scale: {domain: [0, 200]}\n            }\n          }\n        });\n        const _domain = testParseDomainForChannel(model, 'y');\n\n        assert.deepEqual(_domain, [[0, 200]]);\n      });\n\n      it(\n        'should follow the custom domain despite bin',\n        log.wrap(localLogger => {\n          const model = parseUnitModel({\n            mark: 'point',\n            encoding: {\n              y: {\n                field: 'origin',\n                type: 'quantitative',\n                scale: {domain: [0, 200]},\n                bin: {maxbins: 15}\n              }\n            }\n          });\n          const _domain = testParseDomainForChannel(model, 'y');\n\n          assert.deepEqual(_domain, [[0, 200]]);\n        })\n      );\n\n      it('should return the aggregated domain if we do not override it', () => {\n        const model = parseUnitModel({\n          mark: 'point',\n          encoding: {\n            y: {\n              aggregate: 'min',\n              field: 'origin',\n              type: 'quantitative'\n            }\n          }\n        });\n\n        assert.deepEqual(testParseDomainForChannel(model, 'y'), [\n          {\n            data: 'main',\n            field: 'min_origin'\n          }\n        ]);\n      });\n\n      it('should use the aggregated data for domain if specified in config', () => {\n        const model = parseUnitModel({\n          mark: 'point',\n          encoding: {\n            y: {\n              aggregate: 'min',\n              field: 'acceleration',\n              type: 'quantitative'\n            }\n          },\n          config: {\n            scale: {\n              useUnaggregatedDomain: true\n            }\n          }\n        });\n\n        assert.deepEqual(testParseDomainForChannel(model, 'y'), [\n          {\n            data: MAIN,\n            field: 'min_acceleration'\n          },\n          {\n            data: MAIN,\n            field: 'max_acceleration'\n          }\n        ]);\n      });\n    });\n\n    describe('for time', () => {\n      it('should return the correct domain for month T', () => {\n        const model = parseUnitModel({\n          mark: 'point',\n          encoding: {\n            y: {\n              field: 'origin',\n              type: 'temporal',\n              timeUnit: 'month'\n            }\n          }\n        });\n        const _domain = testParseDomainForChannel(model, 'y');\n        assert.deepEqual(_domain, [{data: 'main', field: 'month_origin'}]);\n      });\n\n      it('should return the correct domain for month O', () => {\n        const model = parseUnitModel({\n          mark: 'point',\n          encoding: {\n            y: {\n              field: 'origin',\n              type: 'ordinal',\n              timeUnit: 'month'\n            }\n          }\n        });\n        const _domain = testParseDomainForChannel(model, 'y');\n        assert.deepEqual(_domain, [{data: 'main', field: 'month_origin', sort: true}]);\n      });\n\n      it('should return the correct domain for yearmonth T', () => {\n        const model = parseUnitModel({\n          mark: 'point',\n          encoding: {\n            y: {\n              field: 'origin',\n              type: 'temporal',\n              timeUnit: 'yearmonth'\n            }\n          }\n        });\n        const _domain = testParseDomainForChannel(model, 'y');\n\n        assert.deepEqual(_domain, [{data: 'main', field: 'yearmonth_origin'}]);\n      });\n\n      it('should return the correct domain for month O when specify sort', () => {\n        const sortDef: EncodingSortField<string> = {op: 'mean', field: 'precipitation', order: 'descending'};\n        const model = parseUnitModel({\n          mark: 'bar',\n          encoding: {\n            x: {\n              timeUnit: 'month',\n              field: 'date',\n              type: 'ordinal',\n              sort: sortDef\n            },\n            y: {\n              aggregate: 'mean',\n              field: 'precipitation',\n              type: 'quantitative'\n            }\n          }\n        });\n        const _domain = testParseDomainForChannel(model, 'x');\n\n        assert.deepEqual(_domain, [\n          {\n            data: 'raw',\n            field: 'month_date',\n            sort: sortDef\n          }\n        ]);\n      });\n\n      it('should return the right custom domain with DateTime objects', () => {\n        const model = parseUnitModel({\n          mark: 'point',\n          encoding: {\n            y: {\n              field: 'year',\n              type: 'temporal',\n              scale: {domain: [{year: 1970}, {year: 1980}]}\n            }\n          }\n        });\n        const _domain = testParseDomainForChannel(model, 'y');\n\n        expect(_domain).toEqual([\n          {signal: '{data: datetime(1970, 0, 1, 0, 0, 0, 0)}'},\n          {signal: '{data: datetime(1980, 0, 1, 0, 0, 0, 0)}'}\n        ]);\n      });\n\n      it('should return the right custom domain with date strings', () => {\n        const model = parseUnitModel({\n          mark: 'point',\n          encoding: {\n            y: {\n              field: 'year',\n              type: 'temporal',\n              scale: {domain: ['Jan 1, 2007', 'Jan 1, 2009']}\n            }\n          }\n        });\n        const _domain = testParseDomainForChannel(model, 'y');\n\n        expect(_domain).toEqual([\n          {signal: `{data: datetime(\"Jan 1, 2007\")}`},\n          {signal: `{data: datetime(\"Jan 1, 2009\")}`}\n        ]);\n      });\n    });\n\n    describe('for ordinal', () => {\n      it('should have correct domain for binned ordinal color', () => {\n        const model = parseUnitModel({\n          mark: 'bar',\n          encoding: {\n            color: {field: 'a', bin: true, type: 'ordinal'}\n          }\n        });\n\n        const xDomain = testParseDomainForChannel(model, 'color');\n        assert.deepEqual(xDomain, [\n          {data: 'main', field: 'bin_maxbins_6_a_range', sort: {field: 'bin_maxbins_6_a', op: 'min'}}\n        ]);\n      });\n    });\n\n    describe('for nominal', () => {\n      it('should return correct domain with the provided sort property', () => {\n        const sortDef: EncodingSortField<string> = {op: 'min' as 'min', field: 'Acceleration'};\n        const model = parseUnitModel({\n          mark: 'point',\n          encoding: {\n            y: {field: 'origin', type: 'nominal', sort: sortDef}\n          }\n        });\n        assert.deepEqual(testParseDomainForChannel(model, 'y'), [\n          {\n            data: 'raw',\n            field: 'origin',\n            sort: sortDef\n          }\n        ]);\n      });\n\n      it('should return correct domain with the provided sort property with order property', () => {\n        const sortDef: EncodingSortField<string> = {op: 'min', field: 'Acceleration', order: 'descending'};\n        const model = parseUnitModel({\n          mark: 'point',\n          encoding: {\n            y: {field: 'origin', type: 'nominal', sort: sortDef}\n          }\n        });\n\n        assert.deepEqual(testParseDomainForChannel(model, 'y'), [\n          {\n            data: 'raw',\n            field: 'origin',\n            sort: sortDef\n          }\n        ]);\n      });\n\n      it('should return correct domain without sort if sort is not provided', () => {\n        const model = parseUnitModel({\n          mark: 'point',\n          encoding: {\n            y: {field: 'origin', type: 'nominal'}\n          }\n        });\n\n        assert.deepEqual(testParseDomainForChannel(model, 'y'), [\n          {\n            data: 'main',\n            field: 'origin',\n            sort: true\n          }\n        ]);\n      });\n    });\n  });\n\n  describe('mergeDomains()', () => {\n    it('should merge the same domains', () => {\n      const domain = mergeDomains([\n        {\n          data: 'foo',\n          field: 'a',\n          sort: {field: 'b', op: 'mean'}\n        },\n        {\n          data: 'foo',\n          field: 'a',\n          sort: {field: 'b', op: 'mean'}\n        }\n      ]);\n\n      assert.deepEqual<VgDomain>(domain, {\n        data: 'foo',\n        field: 'a',\n        sort: {field: 'b', op: 'mean'}\n      });\n    });\n\n    it('should drop field if op is count', () => {\n      const domain = mergeDomains([\n        {\n          data: 'foo',\n          field: 'a',\n          sort: {op: 'count', field: 'b'}\n        }\n      ]);\n\n      assert.deepEqual<VgDomain>(domain, {\n        data: 'foo',\n        field: 'a',\n        sort: {op: 'count'}\n      });\n    });\n\n    it('should sort the output domain if one domain is sorted', () => {\n      const domain = mergeDomains([\n        {\n          data: 'foo',\n          field: 'a'\n        },\n        {\n          data: 'foo',\n          field: 'a',\n          sort: {field: 'b', op: 'mean', order: 'descending'}\n        }\n      ]);\n\n      assert.deepEqual<VgDomain>(domain, {\n        data: 'foo',\n        field: 'a',\n        sort: {field: 'b', op: 'mean', order: 'descending'}\n      });\n    });\n\n    it('should sort the output domain if one domain is sorted with true', () => {\n      const domain = mergeDomains([\n        {\n          data: 'foo',\n          field: 'a',\n          sort: true\n        },\n        {\n          data: 'foo',\n          field: 'b'\n        }\n      ]);\n\n      assert.deepEqual(domain, {\n        data: 'foo',\n        fields: ['a', 'b'],\n        sort: true\n      });\n    });\n\n    it('should not sort if no domain is sorted', () => {\n      const domain = mergeDomains([\n        {\n          data: 'foo',\n          field: 'a'\n        },\n        {\n          data: 'foo',\n          field: 'b'\n        }\n      ]);\n\n      assert.deepEqual(domain, {\n        data: 'foo',\n        fields: ['a', 'b']\n      });\n    });\n\n    it('should ignore order ascending as it is the default', () => {\n      const domain = mergeDomains([\n        {\n          data: 'foo',\n          field: 'a',\n          sort: {field: 'b', op: 'mean', order: 'ascending'}\n        },\n        {\n          data: 'foo',\n          field: 'a',\n          sort: {field: 'b', op: 'mean'}\n        }\n      ]);\n\n      assert.deepEqual<VgDomain>(domain, {\n        data: 'foo',\n        field: 'a',\n        sort: {field: 'b', op: 'mean'}\n      });\n    });\n\n    it('should merge domains with the same data', () => {\n      const domain = mergeDomains([\n        {\n          data: 'foo',\n          field: 'a'\n        },\n        {\n          data: 'foo',\n          field: 'a'\n        }\n      ]);\n\n      assert.deepEqual<VgDomain>(domain, {\n        data: 'foo',\n        field: 'a'\n      });\n    });\n\n    it('should merge domains with the same data source', () => {\n      const domain = mergeDomains([\n        {\n          data: 'foo',\n          field: 'a'\n        },\n        {\n          data: 'foo',\n          field: 'b'\n        }\n      ]);\n\n      assert.deepEqual<VgDomain>(domain, {\n        data: 'foo',\n        fields: ['a', 'b']\n      });\n    });\n\n    it('should merge domains with different data source', () => {\n      const domain = mergeDomains([\n        {\n          data: 'foo',\n          field: 'a',\n          sort: true\n        },\n        {\n          data: 'bar',\n          field: 'a',\n          sort: true\n        }\n      ]);\n\n      assert.deepEqual(domain, {\n        fields: [\n          {\n            data: 'foo',\n            field: 'a'\n          },\n          {\n            data: 'bar',\n            field: 'a'\n          }\n        ],\n        sort: true\n      });\n    });\n\n    it('should merge domains with different data and sort', () => {\n      const domain = mergeDomains([\n        {\n          data: 'foo',\n          field: 'a',\n          sort: {\n            op: 'count'\n          }\n        },\n        {\n          data: 'bar',\n          field: 'a'\n        }\n      ]);\n\n      assert.deepEqual<VgDomain>(domain, {\n        fields: [\n          {\n            data: 'foo',\n            field: 'a'\n          },\n          {\n            data: 'bar',\n            field: 'a'\n          }\n        ],\n        sort: {\n          op: 'count'\n        }\n      });\n    });\n\n    it('should merge domains with the same and different data', () => {\n      const domain = mergeDomains([\n        {\n          data: 'foo',\n          field: 'a'\n        },\n        {\n          data: 'foo',\n          field: 'b'\n        },\n        {\n          data: 'bar',\n          field: 'a'\n        }\n      ]);\n\n      assert.deepEqual(domain, {\n        fields: [\n          {\n            data: 'foo',\n            field: 'a'\n          },\n          {\n            data: 'foo',\n            field: 'b'\n          },\n          {\n            data: 'bar',\n            field: 'a'\n          }\n        ]\n      });\n    });\n\n    it('should merge signal domains', () => {\n      const domain = mergeDomains([\n        {\n          signal: 'foo'\n        },\n        {\n          data: 'bar',\n          field: 'a'\n        }\n      ]);\n\n      assert.deepEqual(domain, {\n        fields: [\n          {\n            signal: 'foo'\n          },\n          {\n            data: 'bar',\n            field: 'a'\n          }\n        ]\n      });\n    });\n\n    it(\n      'should warn if sorts conflict',\n      log.wrap(localLogger => {\n        const domain = mergeDomains([\n          {\n            data: 'foo',\n            field: 'a',\n            sort: {\n              op: 'count'\n            }\n          },\n          {\n            data: 'foo',\n            field: 'b',\n            sort: true\n          }\n        ]);\n\n        assert.deepEqual(domain, {\n          data: 'foo',\n          fields: ['a', 'b'],\n          sort: true\n        });\n\n        assert.equal(localLogger.warns[0], log.message.MORE_THAN_ONE_SORT);\n      })\n    );\n\n    it(\n      'should warn if sorts conflict even if we do not union',\n      log.wrap(localLogger => {\n        const domain = mergeDomains([\n          {\n            data: 'foo',\n            field: 'a',\n            sort: {\n              op: 'count'\n            }\n          },\n          {\n            data: 'foo',\n            field: 'a',\n            sort: true\n          }\n        ]);\n\n        assert.deepEqual(domain, {\n          data: 'foo',\n          field: 'a',\n          sort: true\n        });\n\n        assert.equal(localLogger.warns[0], log.message.MORE_THAN_ONE_SORT);\n      })\n    );\n\n    it(\n      'should warn if we had to drop complex sort',\n      log.wrap(localLogger => {\n        const domain = mergeDomains([\n          {\n            data: 'foo',\n            field: 'a',\n            sort: {\n              op: 'mean',\n              field: 'c'\n            }\n          },\n          {\n            data: 'foo',\n            field: 'b'\n          }\n        ]);\n\n        assert.deepEqual(domain, {\n          data: 'foo',\n          fields: ['a', 'b'],\n          sort: true\n        });\n\n        assert.equal(\n          localLogger.warns[0],\n          log.message.domainSortDropped({\n            op: 'mean',\n            field: 'c'\n          })\n        );\n      })\n    );\n\n    it('should not sort explicit domains', () => {\n      const domain = mergeDomains([[1, 2, 3, 4], [3, 4, 5, 6]]);\n\n      assert.deepEqual(domain, {\n        fields: [[1, 2, 3, 4], [3, 4, 5, 6]]\n      });\n    });\n  });\n\n  describe('domainSort()', () => {\n    it('should return undefined for continuous domain', () => {\n      const model = parseUnitModel({\n        mark: 'point',\n        encoding: {\n          x: {field: 'a', type: 'quantitative'}\n        }\n      });\n      const sort = domainSort(model, 'x', ScaleType.LINEAR);\n      assert.deepEqual(sort, undefined);\n    });\n\n    it('should return true by default for discrete domain', () => {\n      const model = parseUnitModel({\n        mark: 'point',\n        encoding: {\n          x: {field: 'a', type: 'ordinal'}\n        }\n      });\n      const sort = domainSort(model, 'x', ScaleType.ORDINAL);\n      assert.deepEqual(sort, true);\n    });\n\n    it('should return true for ascending', () => {\n      const model = parseUnitModel({\n        mark: 'point',\n        encoding: {\n          x: {field: 'a', type: 'quantitative', sort: 'ascending'}\n        }\n      });\n      const sort = domainSort(model, 'x', ScaleType.ORDINAL);\n      assert.deepEqual(sort, true);\n    });\n\n    it('should return undefined if sort = null', () => {\n      const model = parseUnitModel({\n        mark: 'bar',\n        encoding: {\n          x: {field: 'a', type: 'quantitative', sort: null}\n        }\n      });\n      const sort = domainSort(model, 'x', ScaleType.ORDINAL);\n      assert.deepEqual(sort, undefined);\n    });\n\n    it('should return normal sort spec if specified and aggregration is not count', () => {\n      const model = parseUnitModel({\n        mark: 'bar',\n        encoding: {\n          x: {field: 'a', type: 'nominal', sort: {op: 'sum', field: 'y'}},\n          y: {field: 'b', aggregate: 'sum', type: 'quantitative'}\n        }\n      });\n      const sort = domainSort(model, 'x', ScaleType.ORDINAL);\n      assert.deepEqual(sort, {op: 'sum', field: 'y'});\n    });\n\n    it('should return normal sort spec if aggregration is count and field not specified', () => {\n      const model = parseUnitModel({\n        mark: 'bar',\n        encoding: {\n          x: {field: 'a', type: 'nominal', sort: {op: 'count'}},\n          y: {field: 'b', aggregate: 'sum', type: 'quantitative'}\n        }\n      });\n      const sort = domainSort(model, 'x', ScaleType.ORDINAL);\n      assert.deepEqual(sort, {op: 'count'});\n    });\n\n    it('should return true if sort is not specified', () => {\n      const model = parseUnitModel({\n        mark: 'bar',\n        encoding: {\n          x: {field: 'a', type: 'nominal'},\n          y: {field: 'b', aggregate: 'sum', type: 'quantitative'}\n        }\n      });\n      const sort = domainSort(model, 'x', ScaleType.ORDINAL);\n      assert.deepEqual(sort, true);\n    });\n\n    it('should return undefined if sort is specified', () => {\n      const model = parseUnitModel({\n        mark: 'bar',\n        encoding: {\n          x: {field: 'a', type: 'nominal', sort: 'descending'},\n          y: {field: 'b', aggregate: 'sum', type: 'quantitative'}\n        }\n      });\n      assert.deepEqual(domainSort(model, 'x', ScaleType.ORDINAL), {\n        op: 'min',\n        field: 'a',\n        order: 'descending'\n      });\n    });\n\n    it('should return sort spec using derived sort index', () => {\n      const model = parseUnitModel({\n        mark: 'bar',\n        encoding: {\n          x: {field: 'a', type: 'ordinal', sort: ['B', 'A', 'C']},\n          y: {field: 'b', type: 'quantitative'}\n        }\n      });\n      assert.deepEqual(domainSort(model, 'x', ScaleType.ORDINAL), {\n        op: 'min',\n        field: 'x_a_sort_index',\n        order: 'ascending'\n      });\n    });\n\n    it('should return sort with flattened field access', () => {\n      const model = parseUnitModel({\n        mark: 'bar',\n        encoding: {\n          x: {field: 'a', type: 'ordinal', sort: {field: 'foo.bar', op: 'mean'}}\n        }\n      });\n      assert.deepEqual(domainSort(model, 'x', ScaleType.ORDINAL), {op: 'mean', field: 'foo\\\\.bar'});\n    });\n  });\n});\n"]}