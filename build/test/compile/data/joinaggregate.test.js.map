{"version":3,"file":"joinaggregate.test.js","sourceRoot":"","sources":["../../../../test/compile/data/joinaggregate.test.ts"],"names":[],"mappings":"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","sourcesContent":["/* tslint:disable:quotemark */\n\nimport {DataFlowNode} from '../../../src/compile/data/dataflow';\nimport {JoinAggregateTransformNode} from '../../../src/compile/data/joinaggregate';\nimport {makeJoinAggregateFromFacet} from '../../../src/compile/data/joinaggregatefacet';\nimport {Transform} from '../../../src/transform';\n\ndescribe('compile/data/joinaggregate', () => {\n  it('creates correct joinaggregate nodes for calculating sort field of crossed facet', () => {\n    const joinaggregate = makeJoinAggregateFromFacet(null, {\n      row: {field: 'r', type: 'nominal'},\n      column: {field: 'c', type: 'nominal', sort: {op: 'median', field: 'x'}}\n    });\n\n    expect(joinaggregate.assemble()).toEqual({\n      type: 'joinaggregate',\n      ops: ['median'],\n      fields: ['x'],\n      as: ['median_x_by_c'],\n      groupby: ['c']\n    });\n  });\n\n  it('does not create any joinaggregate nodes for crossed facet', () => {\n    expect(\n      makeJoinAggregateFromFacet(null, {\n        row: {field: 'a', type: 'nominal'}\n      })\n    ).toEqual(null);\n  });\n\n  it('should return a proper vg transform', () => {\n    const transform: Transform = {\n      joinaggregate: [\n        {\n          op: 'count',\n          as: 'join_count'\n        }\n      ],\n      groupby: ['f']\n    };\n    const joinaggregate = new JoinAggregateTransformNode(null, transform);\n    expect(joinaggregate.assemble()).toEqual({\n      type: 'joinaggregate',\n      ops: ['count'],\n      fields: [null],\n      as: ['join_count'],\n      groupby: ['f']\n    });\n  });\n\n  it('should augment as with default as', () => {\n    const transform: Transform = {\n      joinaggregate: [\n        {\n          op: 'count',\n          as: undefined // intentionally omit for testing\n        }\n      ],\n      groupby: ['f']\n    };\n    const joinaggregate = new JoinAggregateTransformNode(null, transform);\n    expect(joinaggregate.assemble()).toEqual({\n      type: 'joinaggregate',\n      ops: ['count'],\n      fields: [null],\n      as: ['count'],\n      groupby: ['f']\n    });\n  });\n\n  it('should return a proper produced fields', () => {\n    const transform: Transform = {\n      joinaggregate: [\n        {\n          op: 'count',\n          as: 'count_field'\n        },\n        {\n          op: 'sum',\n          as: 'sum_field'\n        }\n      ]\n    };\n    const joinaggregate = new JoinAggregateTransformNode(null, transform);\n    expect(joinaggregate.producedFields()).toEqual(new Set(['count_field', 'sum_field']));\n  });\n\n  it('should generate the correct dependent fields', () => {\n    const transform: Transform = {\n      joinaggregate: [\n        {\n          field: 'f',\n          op: 'mean',\n          as: 'mean_f'\n        }\n      ],\n      groupby: ['g']\n    };\n    const joinaggregate = new JoinAggregateTransformNode(null, transform);\n    expect(joinaggregate.dependentFields()).toEqual(new Set(['g', 'f']));\n  });\n\n  it('should clone to an equivalent version', () => {\n    const transform: Transform = {\n      joinaggregate: [\n        {\n          op: 'count',\n          as: 'count'\n        }\n      ],\n      groupby: ['f']\n    };\n    const joinaggregate = new JoinAggregateTransformNode(null, transform);\n    expect(joinaggregate).toEqual(joinaggregate.clone());\n  });\n\n  it('should never clone parent', () => {\n    const parent = new DataFlowNode(null);\n    const joinaggregate = new JoinAggregateTransformNode(parent, null);\n    expect(joinaggregate.clone().parent).toBeNull();\n  });\n\n  it('should generate the correct hash', () => {\n    const transform: Transform = {\n      joinaggregate: [\n        {\n          op: 'count',\n          as: 'count'\n        }\n      ],\n      groupby: ['f']\n    };\n    const joinaggregate = new JoinAggregateTransformNode(null, transform);\n    const hash = joinaggregate.hash();\n    expect(hash).toBe('JoinAggregateTransform {\"groupby\":[\"f\"],\"joinaggregate\":[{\"as\":\"count\",\"op\":\"count\"}]}');\n  });\n});\n"]}