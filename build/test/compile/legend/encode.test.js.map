{"version":3,"file":"encode.test.js","sourceRoot":"","sources":["../../../../test/compile/legend/encode.test.ts"],"names":[],"mappings":"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","sourcesContent":["/* tslint:disable:quotemark */\n\nimport {assert} from 'chai';\nimport {SignalRef} from '../../../node_modules/vega';\nimport {COLOR, SIZE} from '../../../src/channel';\nimport {LegendComponent} from '../../../src/compile/legend/component';\nimport * as encode from '../../../src/compile/legend/encode';\nimport {TimeUnit} from '../../../src/timeunit';\nimport {TEMPORAL} from '../../../src/type';\nimport {parseUnitModelWithScale} from '../../util';\n\ndescribe('compile/legend', () => {\n  const symbolLegend = new LegendComponent({type: 'symbol'});\n  const gradientLegend = new LegendComponent({type: 'gradient'});\n\n  describe('encode.symbols', () => {\n    it('should not have fill, strokeDash, or strokeDashOffset', () => {\n      const symbol = encode.symbols(\n        {field: 'a', type: 'nominal'},\n        {},\n        parseUnitModelWithScale({\n          mark: 'point',\n          encoding: {\n            x: {field: 'a', type: 'nominal'},\n            color: {field: 'a', type: 'nominal'}\n          }\n        }),\n        COLOR,\n        symbolLegend\n      );\n      assert.deepEqual(symbol.fill, {value: 'transparent'});\n      assert.isUndefined((symbol || {}).strokeDash);\n      assert.isUndefined((symbol || {}).strokeDashOffset);\n    });\n\n    it('should have fill if a color encoding exists', () => {\n      const symbol = encode.symbols(\n        {field: 'a', type: 'quantitative'},\n        {},\n        parseUnitModelWithScale({\n          mark: {\n            type: 'circle',\n            opacity: 0.3\n          },\n          encoding: {\n            x: {field: 'a', type: 'nominal'},\n            color: {field: 'a', type: 'nominal'},\n            size: {field: 'a', type: 'quantitative'}\n          }\n        }),\n        SIZE,\n        symbolLegend\n      );\n      assert.deepEqual(symbol.fill, {value: 'black'});\n      assert.deepEqual(symbol.fillOpacity, {value: 0.3});\n    });\n\n    it('should return specific symbols.shape.value if user has specified', () => {\n      const symbol = encode.symbols(\n        {field: 'a', type: 'nominal'},\n        {},\n        parseUnitModelWithScale({\n          mark: 'point',\n          encoding: {\n            x: {field: 'a', type: 'nominal'},\n            shape: {value: 'square'}\n          }\n        }),\n        COLOR,\n        symbolLegend\n      );\n      assert.deepEqual(symbol.shape['value'], 'square');\n    });\n\n    it('should have default opacity', () => {\n      const symbol = encode.symbols(\n        {field: 'a', type: 'nominal'},\n        {},\n        parseUnitModelWithScale({\n          mark: 'point',\n          encoding: {\n            x: {field: 'a', type: 'nominal'}\n          }\n        }),\n        COLOR,\n        symbolLegend\n      );\n      assert.deepEqual(symbol.opacity['value'], 0.7); // default opacity is 0.7.\n    });\n\n    it('should return the maximum value when there is a condition', () => {\n      const symbol = encode.symbols(\n        {field: 'a', type: 'nominal'},\n        {},\n        parseUnitModelWithScale({\n          mark: 'point',\n          encoding: {\n            x: {field: 'a', type: 'nominal'},\n            opacity: {\n              condition: {selection: 'brush', value: 1},\n              value: 0\n            }\n          }\n        }),\n        COLOR,\n        symbolLegend\n      );\n      assert.deepEqual(symbol.opacity['value'], 1);\n    });\n  });\n\n  describe('encode.gradient', () => {\n    it('should have default opacity', () => {\n      const gradient = encode.gradient(\n        {field: 'a', type: 'quantitative'},\n        {},\n        parseUnitModelWithScale({\n          mark: 'point',\n          encoding: {\n            x: {field: 'a', type: 'quantitative'}\n          }\n        }),\n        COLOR,\n        gradientLegend\n      );\n\n      assert.deepEqual(gradient.opacity['value'], 0.7); // default opacity is 0.7.\n    });\n  });\n\n  describe('encode.labels', () => {\n    it('should return correct expression for the timeUnit: TimeUnit.MONTH', () => {\n      const model = parseUnitModelWithScale({\n        mark: 'point',\n        encoding: {\n          x: {field: 'a', type: 'temporal'},\n          color: {field: 'a', type: 'temporal', timeUnit: 'month'}\n        }\n      });\n\n      const fieldDef = {field: 'a', type: TEMPORAL, timeUnit: TimeUnit.MONTH};\n      const label = encode.labels(fieldDef, {}, model, COLOR, gradientLegend);\n      const expected = `timeFormat(datum.value, '%b')`;\n      assert.deepEqual((label.text as SignalRef).signal, expected);\n    });\n\n    it('should return correct expression for the timeUnit: TimeUnit.QUARTER', () => {\n      const model = parseUnitModelWithScale({\n        mark: 'point',\n        encoding: {\n          x: {field: 'a', type: 'temporal'},\n          color: {field: 'a', type: 'temporal', timeUnit: 'quarter'}\n        }\n      });\n\n      const fieldDef = {field: 'a', type: TEMPORAL, timeUnit: TimeUnit.QUARTER};\n      const label = encode.labels(fieldDef, {}, model, COLOR, gradientLegend);\n      const expected = `'Q' + quarter(datum.value)`;\n      assert.deepEqual((label.text as SignalRef).signal, expected);\n    });\n  });\n});\n"]}