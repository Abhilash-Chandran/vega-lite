{"version":3,"file":"scale.test.js","sourceRoot":"","sources":["../../test/scale.test.ts"],"names":[],"mappings":"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","sourcesContent":["import {Channel, SCALE_CHANNELS, ScaleChannel} from '../src/channel';\nimport * as scale from '../src/scale';\nimport {\n  channelSupportScaleType,\n  CONTINUOUS_TO_CONTINUOUS_SCALES,\n  getSupportedScaleType,\n  SCALE_TYPES,\n  ScaleType\n} from '../src/scale';\nimport {Type} from '../src/type';\nimport {some, without} from '../src/util';\n\ndescribe('scale', () => {\n  describe('scaleTypeSupportProperty', () => {\n    // Make sure we always edit this when we add new channel\n    it('should have at least one supported scale types for all scale properties', () => {\n      for (const prop of scale.SCALE_PROPERTIES) {\n        expect(\n          some(scale.SCALE_TYPES, scaleType => {\n            return scale.scaleTypeSupportProperty(scaleType, prop);\n          })\n        ).toBeTruthy();\n      }\n    });\n\n    // TODO: write more test blindly (Don't look at our code, just look at D3 code.)\n\n    expect(scale.scaleTypeSupportProperty('bin-linear', 'zero')).toBe(false);\n  });\n\n  describe('scaleTypes', () => {\n    it('should either hasContinuousDomain or hasDiscreteDomain', () => {\n      for (const scaleType of scale.SCALE_TYPES) {\n        expect(scale.hasContinuousDomain(scaleType) !== scale.hasDiscreteDomain(scaleType)).toBeTruthy();\n      }\n    });\n  });\n\n  describe('channelSupportScaleType', () => {\n    // Make sure we always edit this when we add new channel\n    it('should have at least one supported scale types for all channels with scale', () => {\n      for (const channel of SCALE_CHANNELS) {\n        expect(\n          some(SCALE_TYPES, scaleType => {\n            return channelSupportScaleType(channel, scaleType);\n          })\n        ).toBeTruthy();\n      }\n    });\n\n    // Make sure we always edit this when we add new scale type\n    it('should have at least one supported channel for all scale types', () => {\n      for (const scaleType of SCALE_TYPES) {\n        expect(\n          some(SCALE_CHANNELS, channel => {\n            return channelSupportScaleType(channel, scaleType);\n          })\n        ).toBeTruthy();\n      }\n    });\n\n    it('shape should support only ordinal', () => {\n      expect(channelSupportScaleType('shape', 'ordinal')).toBeTruthy();\n      const nonOrdinal = without<ScaleType>(SCALE_TYPES, ['ordinal']);\n      for (const scaleType of nonOrdinal) {\n        expect(!channelSupportScaleType('shape', scaleType)).toBeTruthy();\n      }\n    });\n\n    it('color should support all scale types except band', () => {\n      for (const scaleType of SCALE_TYPES) {\n        expect(channelSupportScaleType('color', scaleType)).toEqual(scaleType !== 'band');\n      }\n    });\n\n    it('x, y, size, opacity should support all continuous scale type as well as band and point', () => {\n      // x,y should use either band or point for ordinal input\n      const scaleTypes = [...CONTINUOUS_TO_CONTINUOUS_SCALES, ScaleType.BAND, ScaleType.POINT];\n\n      for (const channel of ['x', 'y', 'size', 'opacity'] as ScaleChannel[]) {\n        expect(!channelSupportScaleType(channel, 'ordinal')).toBeTruthy();\n        expect(!channelSupportScaleType(channel, 'sequential')).toBeTruthy();\n        for (const scaleType of scaleTypes) {\n          expect(channelSupportScaleType(channel, scaleType)).toBeTruthy();\n        }\n      }\n    });\n  });\n\n  describe('getSupportedScaleType', () => {\n    it('should return correct scale types for quantitative positional channels', () => {\n      const type = Type.QUANTITATIVE;\n      const positionalScaleTypes = [ScaleType.LINEAR, ScaleType.LOG, ScaleType.POW, ScaleType.SQRT];\n\n      // x channel\n      let scaleTypes = getSupportedScaleType(Channel.X, type);\n      expect(positionalScaleTypes).toEqual(scaleTypes);\n\n      // y channel\n      scaleTypes = getSupportedScaleType(Channel.Y, Type.QUANTITATIVE);\n      expect(scaleTypes).toEqual(positionalScaleTypes);\n    });\n\n    it('should return correct scale types for quantitative positional channels with bin', () => {\n      const type = Type.QUANTITATIVE;\n      const positionalScaleTypesBinned = [ScaleType.LINEAR, ScaleType.BIN_LINEAR];\n\n      // x channel\n      let scaleTypes = getSupportedScaleType(Channel.X, type, true);\n      expect(scaleTypes).toEqual(positionalScaleTypesBinned);\n\n      // y channel\n      scaleTypes = getSupportedScaleType(Channel.Y, type, true);\n      expect(scaleTypes).toEqual(positionalScaleTypesBinned);\n    });\n\n    it('should return correct scale types for nominal positional channels', () => {\n      const type = Type.NOMINAL;\n      const nominalPositionalScaleTypes = [ScaleType.POINT, ScaleType.BAND];\n\n      let scaleTypes = getSupportedScaleType(Channel.X, type);\n      expect(scaleTypes).toEqual(nominalPositionalScaleTypes);\n\n      scaleTypes = getSupportedScaleType(Channel.Y, type);\n      expect(scaleTypes).toEqual(nominalPositionalScaleTypes);\n    });\n\n    it('should return correct scale types for temporal positional channels', () => {\n      const type = Type.TEMPORAL;\n      const temporalPositionalScaleTypes = [ScaleType.TIME, ScaleType.UTC];\n\n      let scaleTypes = getSupportedScaleType(Channel.X, type);\n      expect(scaleTypes).toEqual(temporalPositionalScaleTypes);\n\n      scaleTypes = getSupportedScaleType(Channel.Y, type);\n      expect(scaleTypes).toEqual(temporalPositionalScaleTypes);\n    });\n  });\n});\n"]}