{"version":3,"file":"parse.test.js","sourceRoot":"","sources":["../../../../test/compile/data/parse.test.ts"],"names":[],"mappings":"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","sourcesContent":["/* tslint:disable:quotemark */\n\nimport {assert} from 'chai';\nimport {AncestorParse} from '../../../src/compile/data';\nimport {AggregateNode} from '../../../src/compile/data/aggregate';\nimport {BinNode} from '../../../src/compile/data/bin';\nimport {CalculateNode} from '../../../src/compile/data/calculate';\nimport {DataFlowNode} from '../../../src/compile/data/dataflow';\nimport {FilterNode} from '../../../src/compile/data/filter';\nimport {FlattenTransformNode} from '../../../src/compile/data/flatten';\nimport {FoldTransformNode} from '../../../src/compile/data/fold';\nimport {ParseNode} from '../../../src/compile/data/formatparse';\nimport {ImputeNode} from '../../../src/compile/data/impute';\nimport {parseTransformArray} from '../../../src/compile/data/parse';\nimport {SampleTransformNode} from '../../../src/compile/data/sample';\nimport {TimeUnitNode} from '../../../src/compile/data/timeunit';\nimport {WindowTransformNode} from '../../../src/compile/data/window';\nimport {Transform} from '../../../src/transform';\nimport {parseUnitModel} from '../../util';\n\ndescribe('compile/data/parse', () => {\n  describe('parseTransformArray()', () => {\n    it('should return a CalculateNode and a FilterNode', () => {\n      const model = parseUnitModel({\n        data: {values: []},\n        mark: 'point',\n        transform: [{calculate: 'calculate', as: 'as'}, {filter: 'filter'}],\n        encoding: {\n          x: {field: 'a', type: 'temporal', timeUnit: 'month'}\n        }\n      });\n\n      const root = new DataFlowNode(null);\n      const result = parseTransformArray(root, model, new AncestorParse());\n      assert.isTrue(root.children[0] instanceof CalculateNode);\n      assert.isTrue(result instanceof FilterNode);\n    });\n\n    it('should add a parse node for filter transforms with time unit', () => {\n      const model = parseUnitModel({\n        data: {url: 'a.json'},\n        transform: [\n          {\n            filter: {\n              not: {\n                and: [\n                  {\n                    or: [\n                      {\n                        timeUnit: 'year',\n                        field: 'date',\n                        equal: 2005\n                      },\n                      'datum.a > 5'\n                    ]\n                  }\n                ]\n              }\n            }\n          }\n        ],\n        mark: 'point',\n        encoding: {\n          x: {field: 'a', type: 'quantitative'},\n          y: {field: 'b', type: 'temporal'},\n          color: {field: 'c', type: 'ordinal'},\n          shape: {field: 'd', type: 'nominal'}\n        }\n      });\n\n      const root = new DataFlowNode(null);\n      const parse = new AncestorParse();\n      const result = parseTransformArray(root, model, parse);\n\n      assert.isTrue(root.children[0] instanceof ParseNode);\n      assert.isTrue(result instanceof FilterNode);\n      assert.deepEqual((root.children[0] as ParseNode).parse, {\n        date: 'date'\n      });\n      assert.deepEqual(parse.combine(), {date: 'date'});\n    });\n\n    it('should return a BinNode node and a TimeUnitNode', () => {\n      const model = parseUnitModel({\n        data: {values: []},\n        mark: 'point',\n        transform: [{bin: true, field: 'field', as: 'a'}, {timeUnit: 'month', field: 'field', as: 'b'}],\n        encoding: {\n          x: {field: 'a', type: 'temporal', timeUnit: 'month'}\n        }\n      });\n\n      const root = new DataFlowNode(null);\n      const parse = new AncestorParse();\n      const result = parseTransformArray(root, model, parse);\n      expect(root.children[0] instanceof BinNode);\n      expect(result instanceof TimeUnitNode);\n      expect(parse.combine()).toEqual({a: 'number', a_end: 'number', b: 'date', field: 'date'});\n    });\n\n    it('should return a BinNode and a AggregateNode', () => {\n      const model = parseUnitModel({\n        data: {values: []},\n        mark: 'point',\n        transform: [\n          {bin: true, field: 'field', as: 'a'},\n          {aggregate: [{op: 'count', field: 'f', as: 'b'}, {op: 'sum', field: 'f', as: 'c'}], groupby: ['field']}\n        ],\n        encoding: {\n          x: {field: 'a', type: 'temporal', timeUnit: 'month'}\n        }\n      });\n\n      const root = new DataFlowNode(null);\n      const result = parseTransformArray(root, model, new AncestorParse());\n      assert.isTrue(root.children[0] instanceof BinNode);\n      assert.isTrue(result instanceof AggregateNode);\n    });\n\n    it('should return a ImputeTransform Node', () => {\n      const model = parseUnitModel({\n        data: {values: []},\n        mark: 'point',\n        transform: [{impute: 'x', key: 'y', method: 'mean'}],\n        encoding: {\n          x: {field: 'a', type: 'temporal'},\n          y: {field: 'b', type: 'quantitative'}\n        }\n      });\n      const root = new DataFlowNode(null);\n      const result = parseTransformArray(root, model, new AncestorParse());\n      assert.isTrue(root.children[0] instanceof ImputeNode);\n      assert.isTrue(result instanceof ImputeNode);\n    });\n    it('should return a WindowTransform Node', () => {\n      const transform: Transform = {\n        window: [\n          {\n            op: 'count',\n            field: 'f',\n            as: 'b'\n          }\n        ]\n      };\n      const model = parseUnitModel({\n        data: {values: []},\n        mark: 'point',\n        transform: [transform],\n        encoding: {\n          x: {field: 'a', type: 'temporal', timeUnit: 'month'}\n        }\n      });\n      const root = new DataFlowNode(null);\n      parseTransformArray(root, model, new AncestorParse());\n      assert.isTrue(root.children[0] instanceof WindowTransformNode);\n    });\n    it('should return a WindowTransform Node with optional properties', () => {\n      const transform: Transform = {\n        window: [\n          {\n            op: 'row_number',\n            as: 'ordered_row_number'\n          }\n        ],\n        ignorePeers: false,\n        sort: [\n          {\n            field: 'f',\n            order: 'ascending'\n          }\n        ]\n      };\n      const model = parseUnitModel({\n        data: {values: []},\n        mark: 'point',\n        transform: [transform],\n        encoding: {\n          x: {field: 'a', type: 'temporal', timeUnit: 'month'}\n        }\n      });\n      const root = new DataFlowNode(null);\n      parseTransformArray(root, model, new AncestorParse());\n      assert.isTrue(root.children[0] instanceof WindowTransformNode);\n    });\n\n    it('should return a WindowTransform Node', () => {\n      const transform: Transform = {\n        window: [\n          {\n            op: 'count',\n            field: 'f',\n            as: 'b'\n          }\n        ]\n      };\n      const model = parseUnitModel({\n        data: {values: []},\n        mark: 'point',\n        transform: [transform],\n        encoding: {\n          x: {field: 'a', type: 'temporal', timeUnit: 'month'}\n        }\n      });\n      const root = new DataFlowNode(null);\n      parseTransformArray(root, model, new AncestorParse());\n      assert.isTrue(root.children[0] instanceof WindowTransformNode);\n    });\n    it('should return a WindowTransform Node with optional properties', () => {\n      const transform: Transform = {\n        window: [\n          {\n            op: 'row_number',\n            as: 'ordered_row_number'\n          }\n        ],\n        ignorePeers: false,\n        sort: [\n          {\n            field: 'f',\n            order: 'ascending'\n          }\n        ]\n      };\n      const model = parseUnitModel({\n        data: {values: []},\n        mark: 'point',\n        transform: [transform],\n        encoding: {\n          x: {field: 'a', type: 'temporal', timeUnit: 'month'}\n        }\n      });\n      const root = new DataFlowNode(null);\n      parseTransformArray(root, model, new AncestorParse());\n      assert.isTrue(root.children[0] instanceof WindowTransformNode);\n    });\n\n    it('should return a FoldTransformNode', () => {\n      const transform: Transform = {\n        fold: ['a', 'b'],\n        as: ['A', 'B']\n      };\n      const model = parseUnitModel({\n        data: {values: []},\n        mark: 'point',\n        transform: [transform],\n        encoding: {\n          x: {field: 'A', type: 'temporal'},\n          y: {field: 'B', type: 'quantitative'}\n        }\n      });\n      const root = new DataFlowNode(null);\n      const result = parseTransformArray(root, model, new AncestorParse());\n      assert.isTrue(root.children[0] instanceof FoldTransformNode);\n      assert.isTrue(result instanceof FoldTransformNode);\n    });\n\n    it('should return a FlattenTransformNode', () => {\n      const transform: Transform = {\n        flatten: ['a', 'b']\n      };\n      const model = parseUnitModel({\n        data: {values: []},\n        mark: 'point',\n        transform: [transform],\n        encoding: {\n          x: {field: 'a', type: 'temporal'},\n          y: {field: 'b', type: 'quantitative'}\n        }\n      });\n      const root = new DataFlowNode(null);\n      const result = parseTransformArray(root, model, new AncestorParse());\n      assert.isTrue(root.children[0] instanceof FlattenTransformNode);\n      assert.isTrue(result instanceof FlattenTransformNode);\n    });\n\n    it('should return a SampleTransformNode', () => {\n      const transform: Transform = {\n        sample: 1000\n      };\n      const model = parseUnitModel({\n        data: {values: []},\n        mark: 'point',\n        transform: [transform],\n        encoding: {\n          x: {field: 'A', type: 'temporal'},\n          y: {field: 'B', type: 'quantitative'}\n        }\n      });\n      const root = new DataFlowNode(null);\n      const result = parseTransformArray(root, model, new AncestorParse());\n      assert.isTrue(root.children[0] instanceof SampleTransformNode);\n      assert.isTrue(result instanceof SampleTransformNode);\n    });\n\n    it('should return a 3 Transforms from an Impute', () => {\n      const transform: Transform = {\n        impute: 'y',\n        key: 'x',\n        method: 'max',\n        groupby: ['a', 'b'],\n        frame: [-2, 2]\n      };\n\n      const model = parseUnitModel({\n        data: {values: []},\n        mark: 'point',\n        transform: [transform],\n        encoding: {\n          x: {field: 'x', type: 'quantitative'},\n          y: {field: 'y', type: 'quantitative'},\n          color: {field: 'c', type: 'nominal'}\n        }\n      });\n      const root = new DataFlowNode(null);\n      const result = parseTransformArray(root, model, new AncestorParse());\n      assert.isTrue(root.children[0] instanceof ImputeNode);\n      assert.isTrue(result instanceof ImputeNode);\n    });\n  });\n});\n"]}