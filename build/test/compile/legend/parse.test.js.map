{"version":3,"file":"parse.test.js","sourceRoot":"","sources":["../../../../test/compile/legend/parse.test.ts"],"names":[],"mappings":"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","sourcesContent":["/* tslint:disable:quotemark */\n\nimport {COLOR, FILLOPACITY, OPACITY, SHAPE, SIZE, STROKEOPACITY, STROKEWIDTH} from '../../../src/channel';\nimport * as legendParse from '../../../src/compile/legend/parse';\nimport {parseLegend} from '../../../src/compile/legend/parse';\nimport {isFieldDef} from '../../../src/fielddef';\nimport {NormalizedUnitSpec} from '../../../src/spec';\nimport {GEOJSON} from '../../../src/type';\nimport {parseLayerModel, parseUnitModelWithScale} from '../../util';\n\ndescribe('compile/legend', () => {\n  describe('parseUnitLegend()', () => {\n    it(`should not produce a Vega legend object on channel 'shape' with type 'geojson'`, () => {\n      const spec: NormalizedUnitSpec = {\n        mark: 'geoshape',\n        data: {url: 'data/income.json'},\n        transform: [\n          {\n            lookup: 'id',\n            from: {\n              data: {\n                url: 'data/us-10m.json',\n                format: {type: 'topojson', feature: 'states'}\n              },\n              key: 'id'\n            },\n            as: 'geo'\n          }\n        ],\n        encoding: {\n          shape: {field: 'geo', type: 'geojson'}\n        }\n      };\n\n      const unitModel = parseUnitModelWithScale(spec);\n      const channelDef = unitModel.encoding[SHAPE];\n      expect(isFieldDef(channelDef)).toBe(true);\n      if (isFieldDef(channelDef)) {\n        expect(channelDef.type).toEqual(GEOJSON);\n      }\n      parseLegend(unitModel);\n      const legendComp = unitModel.component.legends;\n      expect(legendComp[SHAPE]).not.toBeDefined();\n    });\n  });\n\n  describe('parseLegendForChannel()', () => {\n    it('should produce a Vega legend object with correct type and scale for color', () => {\n      const model = parseUnitModelWithScale({\n        mark: 'point',\n        encoding: {\n          x: {field: 'a', type: 'nominal'},\n          color: {field: 'a', type: 'quantitative'}\n        }\n      });\n\n      const def = legendParse.parseLegendForChannel(model, COLOR).combine();\n      expect(typeof def).toBe('object');\n      expect(def.title).toEqual('a');\n      expect(def.stroke).toEqual('color');\n    });\n\n    it('should produce no legend title when title is null, \"\", or false', () => {\n      for (const val of [null, '', false]) {\n        const model = parseUnitModelWithScale({\n          mark: 'point',\n          encoding: {\n            x: {field: 'a', type: 'nominal'},\n            color: {\n              field: 'a',\n              type: 'quantitative',\n              legend: {title: val as any} // Need to cast as false is not valid, but we want to fall back gracefully\n            }\n          }\n        });\n\n        const def = legendParse.parseLegendForChannel(model, COLOR).combine();\n        expect(def).not.toHaveProperty('title');\n      }\n    });\n\n    it('should store fieldDef.title as explicit', () => {\n      const model = parseUnitModelWithScale({\n        mark: 'point',\n        encoding: {\n          x: {field: 'a', type: 'nominal'},\n          color: {\n            field: 'a',\n            type: 'quantitative',\n            legend: {title: 'foo'} // Need to cast as false is not valid, but we want to fall back gracefully\n          }\n        }\n      });\n\n      const def = legendParse.parseLegendForChannel(model, COLOR).combine();\n      expect(def.title).toEqual('foo');\n    });\n\n    [SIZE, STROKEWIDTH, SHAPE, OPACITY, FILLOPACITY, STROKEOPACITY].forEach(channel => {\n      it(`should produce a Vega legend object with correct type and scale for ${channel}`, () => {\n        const spec: NormalizedUnitSpec = {\n          mark: 'point',\n          encoding: {\n            x: {field: 'a', type: 'nominal'}\n          }\n        };\n        spec.encoding[channel] = {field: 'a', type: 'nominal'};\n\n        const model = parseUnitModelWithScale(spec);\n\n        const def = legendParse.parseLegendForChannel(model, channel).combine();\n\n        const channelDef = model.encoding[channel];\n        if (isFieldDef(channelDef)) {\n          expect(channelDef.type).not.toEqual(GEOJSON);\n        }\n\n        if (channel !== OPACITY) {\n          expect((def.encode.symbols.update.opacity as any).value).toEqual(0.7);\n        } else {\n          expect(def.encode.symbols.update.opacity).not.toBeDefined();\n        }\n        expect(typeof def).toBe('object');\n        expect(def.title).toEqual('a');\n      });\n    });\n  });\n\n  describe('parseNonUnitLegend()', () => {\n    it('should correctly merge orient by favoring explicit orient', () => {\n      const model = parseLayerModel({\n        $schema: 'https://vega.github.io/schema/vega-lite/v3.json',\n        description: \"Google's stock price over time.\",\n        data: {url: 'data/stocks.csv'},\n        layer: [\n          {\n            mark: 'line',\n            encoding: {\n              x: {field: 'date', type: 'temporal'},\n              y: {field: 'price', type: 'quantitative'},\n              color: {field: 'symbol', type: 'nominal'}\n            }\n          },\n          {\n            mark: {type: 'point', filled: true},\n            encoding: {\n              x: {field: 'date', type: 'temporal'},\n              y: {field: 'price', type: 'quantitative'},\n              color: {field: 'symbol', type: 'nominal', legend: {orient: 'left'}}\n            }\n          }\n        ]\n      });\n      model.parseScale();\n      model.parseLegend();\n      expect(model.component.legends.color.explicit.orient).toEqual('left');\n    });\n\n    it('should correctly merge legend that exists only on one plot', () => {\n      const model = parseLayerModel({\n        $schema: 'https://vega.github.io/schema/vega-lite/v3.json',\n        description: \"Google's stock price over time.\",\n        data: {url: 'data/stocks.csv'},\n        layer: [\n          {\n            mark: 'line',\n            encoding: {\n              x: {field: 'date', type: 'temporal'},\n              y: {field: 'price', type: 'quantitative'}\n            }\n          },\n          {\n            mark: {type: 'point', filled: true},\n            encoding: {\n              x: {field: 'date', type: 'temporal'},\n              y: {field: 'price', type: 'quantitative'},\n              color: {field: 'symbol', type: 'nominal'}\n            }\n          }\n        ]\n      });\n      model.parseScale();\n      model.parseLegend();\n      expect(model.component.legends.color).toBeTruthy();\n      expect(model.children[0].component.legends.color).not.toBeDefined();\n      expect(model.children[1].component.legends.color).not.toBeDefined();\n    });\n  });\n});\n"]}