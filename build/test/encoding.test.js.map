{"version":3,"file":"encoding.test.js","sourceRoot":"","sources":["../../test/encoding.test.ts"],"names":[],"mappings":"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","sourcesContent":["import {assert} from 'chai';\nimport {defaultConfig} from '../src/config';\nimport {extractTransformsFromEncoding, normalizeEncoding} from '../src/encoding';\nimport {isPositionFieldDef} from '../src/fielddef';\nimport * as log from '../src/log';\n\ndescribe('encoding', () => {\n  describe('normalizeEncoding', () => {\n    it(\n      'should drop color channel if fill is specified',\n      log.wrap(logger => {\n        const encoding = normalizeEncoding(\n          {\n            color: {field: 'a', type: 'quantitative'},\n            fill: {field: 'b', type: 'quantitative'}\n          },\n          'rule'\n        );\n\n        assert.deepEqual(encoding, {\n          fill: {field: 'b', type: 'quantitative'}\n        });\n        assert.equal(logger.warns[0], log.message.droppingColor('encoding', {fill: true}));\n      })\n    );\n\n    it(\n      'should drop color channel if stroke is specified',\n      log.wrap(logger => {\n        const encoding = normalizeEncoding(\n          {\n            color: {field: 'a', type: 'quantitative'},\n            stroke: {field: 'b', type: 'quantitative'}\n          },\n          'rule'\n        );\n\n        assert.deepEqual(encoding, {\n          stroke: {field: 'b', type: 'quantitative'}\n        });\n        assert.equal(logger.warns[0], log.message.droppingColor('encoding', {stroke: true}));\n      })\n    );\n  });\n\n  describe('extractTransformsFromEncoding', () => {\n    it('should indlude axis in extracted encoding', () => {\n      const encoding = extractTransformsFromEncoding(\n        {\n          x: {field: 'dose', type: 'ordinal', axis: {labelAngle: 15}},\n          y: {field: 'response', type: 'quantitative'}\n        },\n        defaultConfig\n      ).encoding;\n\n      const x = encoding.x;\n      expect(x).toBeDefined();\n      if (isPositionFieldDef(x)) {\n        expect(x.axis).toBeDefined();\n        expect(x.axis.labelAngle).toEqual(15);\n      } else {\n        assert.fail(null, null, 'encoding x is not PositionFieldDef');\n      }\n    });\n    it('should extract time unit from encoding field definition and add axis format', () => {\n      const output = extractTransformsFromEncoding(\n        normalizeEncoding(\n          {\n            x: {timeUnit: 'yearmonthdatehoursminutes', field: 'a', type: 'temporal'},\n            y: {field: 'b', type: 'quantitative'}\n          },\n          'line'\n        ),\n        defaultConfig\n      );\n      expect(output).toEqual({\n        bins: [],\n        timeUnits: [{timeUnit: 'yearmonthdatehoursminutes', field: 'a', as: 'yearmonthdatehoursminutes_a'}],\n        aggregate: [],\n        groupby: ['yearmonthdatehoursminutes_a', 'b'],\n        encoding: {\n          x: {\n            field: 'yearmonthdatehoursminutes_a',\n            type: 'temporal',\n            title: 'a (year-month-date-hours-minutes)',\n            axis: {format: '%b %d, %Y %H:%M'}\n          },\n          y: {field: 'b', type: 'quantitative'}\n        }\n      });\n    });\n    it('should extract aggregates from encoding', () => {\n      const output = extractTransformsFromEncoding(\n        normalizeEncoding(\n          {\n            x: {field: 'a', type: 'quantitative'},\n            y: {\n              aggregate: 'max',\n              field: 'b',\n              type: 'quantitative'\n            }\n          },\n          'line'\n        ),\n        defaultConfig\n      );\n      assert.deepEqual(output, {\n        bins: [],\n        timeUnits: [],\n        aggregate: [{op: 'max', field: 'b', as: 'max_b'}],\n        groupby: ['a'],\n        encoding: {\n          x: {field: 'a', type: 'quantitative'},\n          y: {\n            field: 'max_b',\n            type: 'quantitative',\n            title: 'Max of b'\n          }\n        }\n      });\n    });\n    it('should extract binning from encoding', () => {\n      const output = extractTransformsFromEncoding(\n        normalizeEncoding(\n          {\n            x: {field: 'a', type: 'ordinal', bin: true},\n            y: {type: 'quantitative', aggregate: 'count'}\n          },\n          'bar'\n        ),\n        defaultConfig\n      );\n      assert.deepEqual(output, {\n        bins: [{bin: {maxbins: 10}, field: 'a', as: 'bin_maxbins_10_a'}],\n        timeUnits: [],\n        aggregate: [{op: 'count', as: 'count_*'}],\n        groupby: ['bin_maxbins_10_a_end', 'bin_maxbins_10_a_range', 'bin_maxbins_10_a'],\n        encoding: {\n          x: {field: 'bin_maxbins_10_a', type: 'quantitative', title: 'a (binned)', bin: 'binned'},\n          x2: {field: 'bin_maxbins_10_a_end', type: 'quantitative'},\n          y: {field: 'count_*', type: 'quantitative', title: 'Number of Records'}\n        }\n      });\n    });\n    it('should preserve auxiliary properties (i.e. axis) in encoding', () => {\n      const output = extractTransformsFromEncoding(\n        normalizeEncoding(\n          {\n            x: {field: 'a', type: 'quantitative'},\n            y: {\n              aggregate: 'mean',\n              field: 'b',\n              type: 'quantitative',\n              title: 'foo',\n              axis: {title: 'foo', format: '.2e'}\n            }\n          },\n          'line'\n        ),\n        defaultConfig\n      );\n      expect(output).toEqual({\n        bins: [],\n        timeUnits: [],\n        aggregate: [{op: 'mean', field: 'b', as: 'mean_b'}],\n        groupby: ['a'],\n        encoding: {\n          x: {field: 'a', type: 'quantitative'},\n          y: {\n            field: 'mean_b',\n            type: 'quantitative',\n            title: 'foo',\n            axis: {title: 'foo', format: '.2e'}\n          }\n        }\n      });\n    });\n  });\n});\n"]}