{"version":3,"file":"channel.test.js","sourceRoot":"","sources":["../../test/channel.test.ts"],"names":[],"mappings":"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","sourcesContent":["import {assert} from 'chai';\nimport {isScaleChannel, rangeType, SINGLE_DEF_CHANNELS, supportMark, X2, Y2} from '../src/channel';\nimport {CHANNELS, NONPOSITION_SCALE_CHANNELS, SCALE_CHANNELS, UNIT_CHANNELS} from '../src/channel';\nimport {Encoding} from '../src/encoding';\nimport {CIRCLE, POINT, SQUARE, TICK} from '../src/mark';\nimport {without} from '../src/util';\n\ndescribe('channel', () => {\n  describe('UNIT_CHANNELS', () => {\n    it('should be CHANNELS without row and column', () => {\n      assert.deepEqual(UNIT_CHANNELS, without(CHANNELS, ['row', 'column']));\n    });\n  });\n\n  describe('SINGLE_DEF_CHANNELS', () => {\n    it('should be CHANNELS without detail and order', () => {\n      assert.deepEqual(SINGLE_DEF_CHANNELS, without(CHANNELS, ['detail', 'order']));\n    });\n  });\n\n  describe('SCALE_CHANNELS', () => {\n    it('should be UNIT_CHANNELS without X2, Y2, ORDER, DETAIL, TEXT, LABEL, TOOLTIP', () => {\n      assert.deepEqual(\n        SCALE_CHANNELS,\n        without(UNIT_CHANNELS, [\n          'x2',\n          'y2',\n          'latitude',\n          'longitude',\n          'latitude2',\n          'longitude2',\n          'order',\n          'detail',\n          'key',\n          'text',\n          'label',\n          'tooltip',\n          'href'\n        ])\n      );\n    });\n  });\n\n  describe('NONPOSITION_SCALE_CHANNELS', () => {\n    it('should be SCALE_CHANNELS without x, y, x2, y2', () => {\n      assert.deepEqual(NONPOSITION_SCALE_CHANNELS, without(SCALE_CHANNELS, ['x', 'y']));\n    });\n  });\n\n  describe('isScaleChannel', () => {\n    it('should return true for all scale channel', () => {\n      for (const channel of SCALE_CHANNELS) {\n        assert(isScaleChannel(channel));\n      }\n    });\n  });\n\n  describe('rangeType', () => {\n    it('should be defined for all channels (no error).', () => {\n      for (const c of CHANNELS) {\n        assert.doesNotThrow(() => {\n          rangeType(c);\n        });\n      }\n    });\n  });\n\n  describe('supportMark', () => {\n    it('should support x2 for circle, point, square and tick mark with binned data', () => {\n      const encoding: Encoding<string> = {\n        x: {\n          field: 'bin_start',\n          bin: 'binned',\n          type: 'quantitative',\n          axis: {\n            tickStep: 2\n          }\n        },\n        x2: {\n          field: 'bin_end',\n          type: 'quantitative'\n        },\n        y: {\n          field: 'count',\n          type: 'quantitative'\n        }\n      };\n      assert.isTrue(supportMark(encoding, X2, CIRCLE));\n      assert.isTrue(supportMark(encoding, X2, POINT));\n      assert.isTrue(supportMark(encoding, X2, SQUARE));\n      assert.isTrue(supportMark(encoding, X2, TICK));\n    });\n\n    it('should support y2 for circle, point, square and tick mark with binned data', () => {\n      const encoding: Encoding<string> = {\n        y: {\n          field: 'bin_start',\n          bin: 'binned',\n          type: 'quantitative',\n          axis: {\n            tickStep: 2\n          }\n        },\n        y2: {\n          field: 'bin_end',\n          type: 'quantitative'\n        },\n        x: {\n          field: 'count',\n          type: 'quantitative'\n        }\n      };\n      assert.isTrue(supportMark(encoding, Y2, CIRCLE));\n      assert.isTrue(supportMark(encoding, Y2, POINT));\n      assert.isTrue(supportMark(encoding, Y2, SQUARE));\n      assert.isTrue(supportMark(encoding, Y2, TICK));\n    });\n\n    it('should not support x2 for circle, point, square and tick mark without binned data', () => {\n      const encoding: Encoding<string> = {\n        x: {\n          field: 'bin_start',\n          type: 'quantitative',\n          axis: {\n            tickStep: 2\n          }\n        },\n        x2: {\n          field: 'bin_end',\n          type: 'quantitative'\n        },\n        y: {\n          field: 'count',\n          type: 'quantitative'\n        }\n      };\n      assert.isFalse(supportMark(encoding, X2, CIRCLE));\n      assert.isFalse(supportMark(encoding, X2, POINT));\n      assert.isFalse(supportMark(encoding, X2, SQUARE));\n      assert.isFalse(supportMark(encoding, X2, TICK));\n    });\n\n    it('should not support y2 for circle, point, square and tick mark with binned data', () => {\n      const encoding: Encoding<string> = {\n        y: {\n          field: 'bin_start',\n          type: 'quantitative',\n          axis: {\n            tickStep: 2\n          }\n        },\n        y2: {\n          field: 'bin_end',\n          type: 'quantitative'\n        },\n        x: {\n          field: 'count',\n          type: 'quantitative'\n        }\n      };\n      assert.isFalse(supportMark(encoding, Y2, CIRCLE));\n      assert.isFalse(supportMark(encoding, Y2, POINT));\n      assert.isFalse(supportMark(encoding, Y2, SQUARE));\n      assert.isFalse(supportMark(encoding, Y2, TICK));\n    });\n  });\n});\n"]}