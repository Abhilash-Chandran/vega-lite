{"version":3,"file":"encode.test.js","sourceRoot":"","sources":["../../../../test/compile/legend/encode.test.ts"],"names":[],"mappings":"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","sourcesContent":["/* tslint:disable:quotemark */\n\nimport {SignalRef} from 'vega';\nimport {COLOR, SIZE} from '../../../src/channel';\nimport {LegendComponent} from '../../../src/compile/legend/component';\nimport * as encode from '../../../src/compile/legend/encode';\nimport {TimeUnit} from '../../../src/timeunit';\nimport {TEMPORAL} from '../../../src/type';\nimport {parseUnitModelWithScale} from '../../util';\n\ndescribe('compile/legend', () => {\n  const symbolLegend = new LegendComponent({type: 'symbol'});\n  const gradientLegend = new LegendComponent({type: 'gradient'});\n\n  describe('encode.symbols', () => {\n    it('should not have fill, strokeDash, or strokeDashOffset', () => {\n      const symbol = encode.symbols(\n        {field: 'a', type: 'nominal'},\n        {},\n        parseUnitModelWithScale({\n          mark: 'point',\n          encoding: {\n            x: {field: 'a', type: 'nominal'},\n            color: {field: 'a', type: 'nominal'}\n          }\n        }),\n        COLOR,\n        symbolLegend\n      );\n      expect(symbol.fill).toEqual({value: 'transparent'});\n      expect((symbol || {}).strokeDash).not.toBeDefined();\n      expect((symbol || {}).strokeDashOffset).not.toBeDefined();\n    });\n\n    it('should have fill if a color encoding exists', () => {\n      const symbol = encode.symbols(\n        {field: 'a', type: 'quantitative'},\n        {},\n        parseUnitModelWithScale({\n          mark: {\n            type: 'circle',\n            opacity: 0.3\n          },\n          encoding: {\n            x: {field: 'a', type: 'nominal'},\n            color: {field: 'a', type: 'nominal'},\n            size: {field: 'a', type: 'quantitative'}\n          }\n        }),\n        SIZE,\n        symbolLegend\n      );\n      expect(symbol.fill).toEqual({value: 'black'});\n      expect(symbol.fillOpacity).toEqual({value: 0.3});\n    });\n\n    it('should return specific symbols.shape.value if user has specified', () => {\n      const symbol = encode.symbols(\n        {field: 'a', type: 'nominal'},\n        {},\n        parseUnitModelWithScale({\n          mark: 'point',\n          encoding: {\n            color: {field: 'a', type: 'nominal'},\n            shape: {value: 'square'}\n          }\n        }),\n        COLOR,\n        symbolLegend\n      );\n      expect(symbol.shape['value']).toEqual('square');\n    });\n\n    it('should have default opacity', () => {\n      const symbol = encode.symbols(\n        {field: 'a', type: 'nominal'},\n        {},\n        parseUnitModelWithScale({\n          mark: 'point',\n          encoding: {\n            color: {field: 'a', type: 'nominal'}\n          }\n        }),\n        COLOR,\n        symbolLegend\n      );\n      expect(symbol.opacity['value']).toEqual(0.7); // default opacity is 0.7.\n    });\n\n    it('should return the maximum value when there is a condition', () => {\n      const symbol = encode.symbols(\n        {field: 'a', type: 'nominal'},\n        {},\n        parseUnitModelWithScale({\n          mark: 'point',\n          encoding: {\n            color: {field: 'a', type: 'nominal'},\n            opacity: {\n              condition: {selection: 'brush', value: 1},\n              value: 0\n            }\n          }\n        }),\n        COLOR,\n        symbolLegend\n      );\n      expect(symbol.opacity['value']).toEqual(1);\n    });\n  });\n\n  describe('encode.gradient', () => {\n    it('should have default opacity', () => {\n      const gradient = encode.gradient(\n        {field: 'a', type: 'quantitative'},\n        {},\n        parseUnitModelWithScale({\n          mark: 'point',\n          encoding: {\n            color: {field: 'a', type: 'nominal'}\n          }\n        }),\n        COLOR,\n        gradientLegend\n      );\n\n      expect(gradient.opacity['value']).toEqual(0.7); // default opacity is 0.7.\n    });\n  });\n\n  describe('encode.labels', () => {\n    it('should return correct expression for the timeUnit: TimeUnit.MONTH', () => {\n      const model = parseUnitModelWithScale({\n        mark: 'point',\n        encoding: {\n          x: {field: 'a', type: 'temporal'},\n          color: {field: 'a', type: 'temporal', timeUnit: 'month'}\n        }\n      });\n\n      const fieldDef = {field: 'a', type: TEMPORAL, timeUnit: TimeUnit.MONTH};\n      const label = encode.labels(fieldDef, {}, model, COLOR, gradientLegend);\n      const expected = `timeFormat(datum.value, '%b')`;\n      expect((label.text as SignalRef).signal).toEqual(expected);\n    });\n\n    it('should return correct expression for the timeUnit: TimeUnit.QUARTER', () => {\n      const model = parseUnitModelWithScale({\n        mark: 'point',\n        encoding: {\n          x: {field: 'a', type: 'temporal'},\n          color: {field: 'a', type: 'temporal', timeUnit: 'quarter'}\n        }\n      });\n\n      const fieldDef = {field: 'a', type: TEMPORAL, timeUnit: TimeUnit.QUARTER};\n      const label = encode.labels(fieldDef, {}, model, COLOR, gradientLegend);\n      const expected = `'Q' + quarter(datum.value)`;\n      expect((label.text as SignalRef).signal).toEqual(expected);\n    });\n  });\n});\n"]}