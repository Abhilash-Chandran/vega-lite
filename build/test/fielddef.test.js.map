{"version":3,"file":"fielddef.test.js","sourceRoot":"","sources":["../../test/fielddef.test.ts"],"names":[],"mappings":"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","sourcesContent":["import {COUNTING_OPS} from '../src/aggregate';\nimport {Channel, CHANNELS} from '../src/channel';\nimport {channelCompatibility, defaultTitle, defaultType, normalize, TypedFieldDef, vgField} from '../src/fielddef';\nimport * as log from '../src/log';\nimport {TimeUnit} from '../src/timeunit';\nimport {QUANTITATIVE, TEMPORAL} from '../src/type';\n\ndescribe('fieldDef', () => {\n  describe('vgField()', () => {\n    it('should access flattened fields', () => {\n      expect(vgField({field: 'foo.bar\\\\.baz'})).toEqual('foo\\\\.bar\\\\.baz');\n    });\n\n    it('should access flattened fields in expression', () => {\n      expect(vgField({field: 'foo.bar\\\\.baz'}, {expr: 'datum'})).toEqual('datum[\"foo.bar.baz\"]');\n    });\n  });\n\n  describe('defaultType()', () => {\n    it('should return temporal if there is timeUnit', () => {\n      expect(defaultType({timeUnit: 'month', field: 'a'} as TypedFieldDef<string>, 'x')).toEqual('temporal');\n    });\n\n    it('should return quantitative if there is bin', () => {\n      expect(defaultType({bin: true, field: 'a'} as TypedFieldDef<string>, 'x')).toEqual('quantitative');\n    });\n\n    it('should return quantitative for a channel that supports measure', () => {\n      for (const c of ['x', 'y', 'size', 'opacity', 'order'] as Channel[]) {\n        expect(defaultType({field: 'a'} as TypedFieldDef<string>, c)).toEqual('quantitative');\n      }\n    });\n\n    it('should return nominal for a channel that does not support measure', () => {\n      for (const c of ['color', 'shape', 'row', 'column'] as Channel[]) {\n        expect(defaultType({field: 'a'} as TypedFieldDef<string>, c)).toEqual('nominal');\n      }\n    });\n  });\n\n  describe('normalize()', () => {\n    it(\n      'should convert primitive type to value def',\n      log.wrap(localLogger => {\n        expect(normalize(5 as any, 'x')).toEqual({value: 5});\n        expect(localLogger.warns.length).toEqual(1);\n      })\n    );\n\n    it('should return fieldDef with full type name.', () => {\n      const fieldDef: TypedFieldDef<string> = {field: 'a', type: 'q' as any};\n      expect(normalize(fieldDef, 'x')).toEqual({field: 'a', type: 'quantitative'});\n    });\n\n    it(\n      'normalizes yearmonthday to become yearmonthdate.',\n      log.wrap(localLogger => {\n        const fieldDef: TypedFieldDef<string> = {\n          timeUnit: 'yearmonthday' as TimeUnit, // Need to cast here as this is intentionally wrong\n          field: 'a',\n          type: 'temporal'\n        };\n        expect(normalize(fieldDef, 'x')).toEqual({\n          timeUnit: 'yearmonthdate',\n          field: 'a',\n          type: 'temporal'\n        });\n        expect(localLogger.warns[0]).toEqual(log.message.dayReplacedWithDate('yearmonthday'));\n      })\n    );\n\n    it(\n      'should replace other type with quantitative for a field with counting aggregate.',\n      log.wrap(localLogger => {\n        for (const aggregate of COUNTING_OPS) {\n          const fieldDef: TypedFieldDef<string> = {aggregate, field: 'a', type: 'nominal'};\n          expect(normalize(fieldDef, 'x')).toEqual({aggregate, field: 'a', type: 'quantitative'});\n        }\n        expect(localLogger.warns.length).toEqual(4);\n      })\n    );\n\n    it(\n      'should return fieldDef with default type and throw warning if type is missing.',\n      log.wrap(localLogger => {\n        const fieldDef = {field: 'a'} as TypedFieldDef<string>;\n        expect(normalize(fieldDef, 'x')).toEqual({field: 'a', type: 'quantitative'});\n        expect(localLogger.warns[0]).toEqual(log.message.missingFieldType('x', 'quantitative'));\n      })\n    );\n\n    it(\n      'should drop invalid aggregate ops and throw warning.',\n      log.wrap(localLogger => {\n        const fieldDef: TypedFieldDef<string> = {aggregate: 'boxplot', field: 'a', type: 'quantitative'};\n        expect(normalize(fieldDef, 'x')).toEqual({field: 'a', type: 'quantitative'});\n        expect(localLogger.warns[0]).toEqual(log.message.invalidAggregate('boxplot'));\n      })\n    );\n  });\n\n  describe('channelCompatability', () => {\n    describe('row/column', () => {\n      it('is incompatible with continuous field', () => {\n        for (const channel of ['row', 'column'] as Channel[]) {\n          expect(!channelCompatibility({field: 'a', type: 'quantitative'}, channel).compatible).toBeTruthy();\n        }\n      });\n      it('is compatible with discrete field', () => {\n        for (const channel of ['row', 'column'] as Channel[]) {\n          expect(channelCompatibility({field: 'a', type: 'nominal'}, channel).compatible).toBeTruthy();\n        }\n      });\n    });\n\n    describe('x/y/color/text/detail', () => {\n      it('is compatible with continuous field', () => {\n        for (const channel of ['x', 'y', 'color', 'text', 'detail'] as Channel[]) {\n          expect(channelCompatibility({field: 'a', type: 'quantitative'}, channel).compatible).toBeTruthy();\n        }\n      });\n      it('is compatible with discrete field', () => {\n        for (const channel of ['x', 'y', 'color', 'text', 'detail'] as Channel[]) {\n          expect(channelCompatibility({field: 'a', type: 'nominal'}, channel).compatible).toBeTruthy();\n        }\n      });\n    });\n\n    describe('opacity/size/x2/y2', () => {\n      it('is compatible with continuous field', () => {\n        for (const channel of ['opacity', 'size', 'x2', 'y2'] as Channel[]) {\n          expect(channelCompatibility({field: 'a', type: 'quantitative'}, channel).compatible).toBeTruthy();\n        }\n      });\n\n      it('is compatible with binned field', () => {\n        for (const channel of ['opacity', 'size', 'x2', 'y2'] as Channel[]) {\n          expect(channelCompatibility({bin: true, field: 'a', type: 'quantitative'}, channel).compatible).toBeTruthy();\n        }\n      });\n\n      it('is incompatible with nominal field', () => {\n        for (const channel of ['opacity', 'size', 'x2', 'y2'] as Channel[]) {\n          expect(!channelCompatibility({field: 'a', type: 'nominal'}, channel).compatible).toBeTruthy();\n        }\n      });\n    });\n\n    describe('shape', () => {\n      it('is compatible with nominal field', () => {\n        expect(channelCompatibility({field: 'a', type: 'nominal'}, 'shape').compatible).toBeTruthy();\n      });\n      it('is compatible with ordinal field', () => {\n        expect(channelCompatibility({field: 'a', type: 'ordinal'}, 'shape').compatible).toBeTruthy();\n      });\n      it('is incompatible with quantitative field', () => {\n        expect(!channelCompatibility({field: 'a', type: 'quantitative'}, 'shape').compatible).toBeTruthy();\n      });\n\n      it('is the only channel that is incompatible with geojson field', () => {\n        for (const channel of CHANNELS) {\n          expect(\n            channelCompatibility({field: 'a', type: 'geojson'}, channel).compatible === (channel === 'shape')\n          ).toBeTruthy();\n        }\n      });\n    });\n\n    describe('order', () => {\n      it('is incompatible with nominal field', () => {\n        expect(!channelCompatibility({field: 'a', type: 'nominal'}, 'order').compatible).toBeTruthy();\n      });\n      it('is compatible with ordinal field', () => {\n        expect(channelCompatibility({field: 'a', type: 'ordinal'}, 'order').compatible).toBeTruthy();\n      });\n      it('is compatible with quantitative field', () => {\n        expect(channelCompatibility({field: 'a', type: 'quantitative'}, 'order').compatible).toBeTruthy();\n      });\n    });\n  });\n\n  describe('defaultTitle()', () => {\n    it('should return correct title for aggregate', () => {\n      expect(defaultTitle({field: 'f', aggregate: 'mean'}, {})).toEqual('Mean of f');\n    });\n\n    it('should return correct title for count', () => {\n      expect(defaultTitle({aggregate: 'count'}, {countTitle: 'baz!'})).toEqual('baz!');\n    });\n\n    it('should return correct title for bin', () => {\n      const fieldDef = {field: 'f', type: QUANTITATIVE, bin: true};\n      expect(defaultTitle(fieldDef, {})).toEqual('f (binned)');\n    });\n\n    it('should return correct title for bin', () => {\n      const fieldDef = {field: 'f', type: QUANTITATIVE, bin: true};\n      expect(defaultTitle(fieldDef, {fieldTitle: 'functional'})).toEqual('BIN(f)');\n    });\n\n    it('should return correct title for timeUnit', () => {\n      const fieldDef = {field: 'f', type: TEMPORAL, timeUnit: TimeUnit.MONTH};\n      expect(defaultTitle(fieldDef, {})).toEqual('f (month)');\n    });\n\n    it('should return correct title for timeUnit', () => {\n      const fieldDef = {field: 'f', type: TEMPORAL, timeUnit: TimeUnit.YEARMONTHDATE};\n      expect(defaultTitle(fieldDef, {})).toEqual('f (year-month-date)');\n    });\n\n    it('should return correct title for timeUnit', () => {\n      const fieldDef = {field: 'f', type: TEMPORAL, timeUnit: TimeUnit.DAY};\n      expect(defaultTitle(fieldDef, {})).toEqual('f (day)');\n    });\n\n    it('should return correct title for timeUnit', () => {\n      const fieldDef = {field: 'f', type: TEMPORAL, timeUnit: TimeUnit.YEARQUARTER};\n      expect(defaultTitle(fieldDef, {})).toEqual('f (year-quarter)');\n    });\n\n    it('should return correct title for raw field', () => {\n      const fieldDef = {field: 'f', type: TEMPORAL};\n      expect(defaultTitle(fieldDef, {})).toEqual('f');\n    });\n  });\n});\n"]}