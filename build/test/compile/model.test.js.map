{"version":3,"file":"model.test.js","sourceRoot":"","sources":["../../../test/compile/model.test.ts"],"names":[],"mappings":"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","sourcesContent":["import {assert} from 'chai';\nimport {NameMap} from '../../src/compile/model';\nimport {parseFacetModel, parseFacetModelWithScale} from '../util';\n\ndescribe('Model', () => {\n  describe('NameMap', () => {\n    it('should rename correctly', () => {\n      const map = new NameMap();\n      assert.equal(map.get('a'), 'a');\n\n      map.rename('a', 'b');\n      assert.equal(map.get('a'), 'b');\n      assert.equal(map.get('b'), 'b');\n\n      map.rename('b', 'c');\n      assert.equal(map.get('a'), 'c');\n      assert.equal(map.get('b'), 'c');\n      assert.equal(map.get('c'), 'c');\n\n      map.rename('z', 'a');\n      assert.equal(map.get('a'), 'c');\n      assert.equal(map.get('b'), 'c');\n      assert.equal(map.get('c'), 'c');\n      assert.equal(map.get('z'), 'c');\n    });\n  });\n\n  describe('hasDescendantWithFieldOnChannel', () => {\n    it('should return true if a child plot has a field on x', () => {\n      const model = parseFacetModel({\n        facet: {row: {field: 'a', type: 'nominal'}},\n        spec: {\n          mark: 'point',\n          encoding: {\n            x: {field: 'x', type: 'quantitative'}\n          }\n        }\n      });\n      assert(model.hasDescendantWithFieldOnChannel('x'));\n    });\n\n    it('should return true if a descendant plot has x', () => {\n      const model = parseFacetModel({\n        facet: {row: {field: 'a', type: 'nominal'}},\n        spec: {\n          layer: [\n            {\n              mark: 'point',\n              encoding: {\n                x: {field: 'x', type: 'quantitative'}\n              }\n            },\n            {\n              mark: 'point',\n              encoding: {\n                color: {field: 'x', type: 'quantitative'}\n              }\n            }\n          ]\n        }\n      });\n      assert(model.hasDescendantWithFieldOnChannel('x'));\n    });\n\n    it('should return false if no descendant plot has a field on x', () => {\n      const model = parseFacetModel({\n        facet: {row: {field: 'a', type: 'nominal'}},\n        spec: {\n          mark: 'point',\n          encoding: {\n            color: {field: 'x', type: 'quantitative'}\n          }\n        }\n      });\n      assert(!model.hasDescendantWithFieldOnChannel('x'));\n    });\n\n    it('should return false if no descendant plot has a field on x', () => {\n      const model = parseFacetModel({\n        facet: {row: {field: 'a', type: 'nominal'}},\n        spec: {\n          layer: [\n            {\n              mark: 'point',\n              encoding: {\n                color: {field: 'x', type: 'quantitative'}\n              }\n            },\n            {\n              mark: 'point',\n              encoding: {\n                color: {field: 'x', type: 'quantitative'}\n              }\n            }\n          ]\n        }\n      });\n      assert(!model.hasDescendantWithFieldOnChannel('x'));\n    });\n  });\n\n  describe('getSizeSignalRef', () => {\n    it('returns formula for step if parent is facet', () => {\n      const model = parseFacetModelWithScale({\n        facet: {\n          row: {field: 'a', type: 'ordinal'}\n        },\n        spec: {\n          mark: 'point',\n          encoding: {\n            x: {\n              field: 'b',\n              type: 'nominal',\n              scale: {\n                padding: 0.345\n              }\n            }\n          }\n        },\n        resolve: {\n          scale: {x: 'independent'}\n        }\n      });\n\n      assert.deepEqual(model.child.getSizeSignalRef('width'), {\n        signal: `bandspace(datum[\\\"distinct_b\\\"], 1, 0.345) * child_x_step`\n      });\n    });\n  });\n});\n"]}