{"version":3,"file":"model.test.js","sourceRoot":"","sources":["../../../test/compile/model.test.ts"],"names":[],"mappings":"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","sourcesContent":["import {NameMap} from '../../src/compile/model';\nimport {parseFacetModel, parseFacetModelWithScale} from '../util';\n\ndescribe('Model', () => {\n  describe('NameMap', () => {\n    it('should rename correctly', () => {\n      const map = new NameMap();\n      expect(map.get('a')).toBe('a');\n\n      map.rename('a', 'b');\n      expect(map.get('a')).toBe('b');\n      expect(map.get('b')).toBe('b');\n\n      map.rename('b', 'c');\n      expect(map.get('a')).toBe('c');\n      expect(map.get('b')).toBe('c');\n      expect(map.get('c')).toBe('c');\n\n      map.rename('z', 'a');\n      expect(map.get('a')).toBe('c');\n      expect(map.get('b')).toBe('c');\n      expect(map.get('c')).toBe('c');\n      expect(map.get('z')).toBe('c');\n    });\n  });\n\n  describe('hasDescendantWithFieldOnChannel', () => {\n    it('should return true if a child plot has a field on x', () => {\n      const model = parseFacetModel({\n        facet: {row: {field: 'a', type: 'nominal'}},\n        spec: {\n          mark: 'point',\n          encoding: {\n            x: {field: 'x', type: 'quantitative'}\n          }\n        }\n      });\n      expect(model.hasDescendantWithFieldOnChannel('x')).toBeTruthy();\n    });\n\n    it('should return true if a descendant plot has x', () => {\n      const model = parseFacetModel({\n        facet: {row: {field: 'a', type: 'nominal'}},\n        spec: {\n          layer: [\n            {\n              mark: 'point',\n              encoding: {\n                x: {field: 'x', type: 'quantitative'}\n              }\n            },\n            {\n              mark: 'point',\n              encoding: {\n                color: {field: 'x', type: 'quantitative'}\n              }\n            }\n          ]\n        }\n      });\n      expect(model.hasDescendantWithFieldOnChannel('x')).toBeTruthy();\n    });\n\n    it('should return false if no descendant plot has a field on x', () => {\n      const model = parseFacetModel({\n        facet: {row: {field: 'a', type: 'nominal'}},\n        spec: {\n          mark: 'point',\n          encoding: {\n            color: {field: 'x', type: 'quantitative'}\n          }\n        }\n      });\n      expect(!model.hasDescendantWithFieldOnChannel('x')).toBeTruthy();\n    });\n\n    it('should return false if no descendant plot has a field on x', () => {\n      const model = parseFacetModel({\n        facet: {row: {field: 'a', type: 'nominal'}},\n        spec: {\n          layer: [\n            {\n              mark: 'point',\n              encoding: {\n                color: {field: 'x', type: 'quantitative'}\n              }\n            },\n            {\n              mark: 'point',\n              encoding: {\n                color: {field: 'x', type: 'quantitative'}\n              }\n            }\n          ]\n        }\n      });\n      expect(!model.hasDescendantWithFieldOnChannel('x')).toBeTruthy();\n    });\n  });\n\n  describe('getSizeSignalRef', () => {\n    it('returns formula for step if parent is facet', () => {\n      const model = parseFacetModelWithScale({\n        facet: {\n          row: {field: 'a', type: 'ordinal'}\n        },\n        spec: {\n          mark: 'point',\n          encoding: {\n            x: {\n              field: 'b',\n              type: 'nominal',\n              scale: {\n                padding: 0.345\n              }\n            }\n          }\n        },\n        resolve: {\n          scale: {x: 'independent'}\n        }\n      });\n\n      expect(model.child.getSizeSignalRef('width')).toEqual({\n        signal: `bandspace(datum[\\\"distinct_b\\\"], 1, 0.345) * child_x_step`\n      });\n    });\n  });\n});\n"]}