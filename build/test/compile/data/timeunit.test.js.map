{"version":3,"file":"timeunit.test.js","sourceRoot":"","sources":["../../../../test/compile/data/timeunit.test.ts"],"names":[],"mappings":";AAAA,8BAA8B;;AAE9B,6BAA4B;AAC5B,+DAAgE;AAGhE,mCAA0C;AAE1C,SAAS,oBAAoB,CAAC,KAAqB;IACjD,OAAO,uBAAY,CAAC,gBAAgB,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,QAAQ,EAAE,CAAC;AAC/D,CAAC;AAED,SAAS,qBAAqB,CAAC,CAAoB;IACjD,OAAO,uBAAY,CAAC,iBAAiB,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC;AAC5D,CAAC;AAED,QAAQ,CAAC,uBAAuB,EAAE;IAChC,QAAQ,CAAC,WAAW,EAAE;QACpB,EAAE,CAAC,iDAAiD,EAAE;YACpD,IAAM,KAAK,GAAG,qBAAc,CAAC;gBAC3B,IAAI,EAAE,EAAC,MAAM,EAAE,EAAE,EAAC;gBAClB,IAAI,EAAE,OAAO;gBACb,QAAQ,EAAE;oBACR,CAAC,EAAE,EAAC,KAAK,EAAE,GAAG,EAAE,IAAI,EAAE,UAAU,EAAE,QAAQ,EAAE,OAAO,EAAC;iBACrD;aACF,CAAC,CAAC;YAEH,aAAM,CAAC,SAAS,CAAC,oBAAoB,CAAC,KAAK,CAAC,EAAE;gBAC5C;oBACE,IAAI,EAAE,SAAS;oBACf,EAAE,EAAE,SAAS;oBACb,IAAI,EAAE,+CAA+C;iBACtD;aACF,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,sEAAsE,EAAE;YACzE,IAAM,CAAC,GAAsB,EAAC,KAAK,EAAE,MAAM,EAAE,EAAE,EAAE,YAAY,EAAE,QAAQ,EAAE,OAAO,EAAC,CAAC;YAElF,aAAM,CAAC,SAAS,CAAC,qBAAqB,CAAC,CAAC,CAAC,EAAE;gBACzC;oBACE,IAAI,EAAE,SAAS;oBACf,EAAE,EAAE,YAAY;oBAChB,IAAI,EAAE,kDAAkD;iBACzD;aACF,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IAEH,QAAQ,CAAC,MAAM,EAAE;QACf,EAAE,CAAC,kCAAkC,EAAE;YACrC,IAAM,KAAK,GAAG,qBAAc,CAAC;gBAC3B,IAAI,EAAE,EAAC,MAAM,EAAE,EAAE,EAAC;gBAClB,IAAI,EAAE,OAAO;gBACb,QAAQ,EAAE;oBACR,CAAC,EAAE,EAAC,KAAK,EAAE,GAAG,EAAE,IAAI,EAAE,UAAU,EAAE,QAAQ,EAAE,OAAO,EAAC;iBACrD;aACF,CAAC,CAAC;YACH,IAAM,YAAY,GAAG,uBAAY,CAAC,gBAAgB,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;YAChE,aAAM,CAAC,SAAS,CAAC,YAAY,CAAC,IAAI,EAAE,EAAE,sEAAsE,CAAC,CAAC;QAChH,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","sourcesContent":["/* tslint:disable:quotemark */\n\nimport {assert} from 'chai';\nimport {TimeUnitNode} from '../../../src/compile/data/timeunit';\nimport {ModelWithField} from '../../../src/compile/model';\nimport {TimeUnitTransform} from '../../../src/transform';\nimport {parseUnitModel} from '../../util';\n\nfunction assembleFromEncoding(model: ModelWithField) {\n  return TimeUnitNode.makeFromEncoding(null, model).assemble();\n}\n\nfunction assembleFromTransform(t: TimeUnitTransform) {\n  return TimeUnitNode.makeFromTransform(null, t).assemble();\n}\n\ndescribe('compile/data/timeunit', () => {\n  describe('parseUnit', () => {\n    it('should return a dictionary of formula transform', () => {\n      const model = parseUnitModel({\n        data: {values: []},\n        mark: 'point',\n        encoding: {\n          x: {field: 'a', type: 'temporal', timeUnit: 'month'}\n        }\n      });\n\n      assert.deepEqual(assembleFromEncoding(model), [\n        {\n          type: 'formula',\n          as: 'month_a',\n          expr: 'datetime(0, month(datum[\"a\"]), 1, 0, 0, 0, 0)'\n        }\n      ]);\n    });\n\n    it('should return a dictionary of formula transform from transform array', () => {\n      const t: TimeUnitTransform = {field: 'date', as: 'month_date', timeUnit: 'month'};\n\n      assert.deepEqual(assembleFromTransform(t), [\n        {\n          type: 'formula',\n          as: 'month_date',\n          expr: 'datetime(0, month(datum[\"date\"]), 1, 0, 0, 0, 0)'\n        }\n      ]);\n    });\n  });\n\n  describe('hash', () => {\n    it('should generate the correct hash', () => {\n      const model = parseUnitModel({\n        data: {values: []},\n        mark: 'point',\n        encoding: {\n          x: {field: 'a', type: 'temporal', timeUnit: 'month'}\n        }\n      });\n      const timeUnitNode = TimeUnitNode.makeFromEncoding(null, model);\n      assert.deepEqual(timeUnitNode.hash(), 'TimeUnit {\"month_a\":{\"as\":\"month_a\",\"field\":\"a\",\"timeUnit\":\"month\"}}');\n    });\n  });\n});\n"]}