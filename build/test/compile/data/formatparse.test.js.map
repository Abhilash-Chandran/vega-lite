{"version":3,"file":"formatparse.test.js","sourceRoot":"","sources":["../../../../test/compile/data/formatparse.test.ts"],"names":[],"mappings":"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","sourcesContent":["/* tslint:disable:quotemark */\nimport {AncestorParse} from '../../../src/compile/data';\nimport {DataFlowNode} from '../../../src/compile/data/dataflow';\nimport {ParseNode} from '../../../src/compile/data/formatparse';\nimport {parseTransformArray} from '../../../src/compile/data/parse';\nimport {ModelWithField} from '../../../src/compile/model';\nimport * as log from '../../../src/log';\nimport {parseFacetModel, parseUnitModel} from '../../util';\n\ndescribe('compile/data/formatparse', () => {\n  describe('parseUnit', () => {\n    it('should flatten nested fields that are used to sort domains', () => {\n      const model = parseUnitModel({\n        mark: 'point',\n        encoding: {\n          x: {field: 'a', type: 'ordinal', sort: {field: 'foo.bar', op: 'mean'}}\n        }\n      });\n\n      expect(ParseNode.makeImplicitFromEncoding(null, model, new AncestorParse()).parse).toEqual({\n        'foo.bar': 'flatten'\n      });\n    });\n\n    it('should return a correct customized parse.', () => {\n      const model = parseUnitModel({\n        data: {url: 'a.json', format: {parse: {c: 'number', d: 'date'}}},\n        mark: 'point',\n        encoding: {\n          x: {field: 'a', type: 'quantitative'},\n          y: {field: 'b', type: 'temporal'},\n          color: {field: 'c', type: 'ordinal'},\n          shape: {field: 'c', type: 'nominal'}\n        }\n      });\n\n      const ancestorParese = new AncestorParse();\n      expect(ParseNode.makeImplicitFromEncoding(null, model, ancestorParese).parse).toEqual({\n        b: 'date'\n      });\n\n      expect(ParseNode.makeExplicit(null, model, ancestorParese).parse).toEqual({\n        c: 'number',\n        d: 'date'\n      });\n    });\n\n    it('should include parse for all applicable fields, and exclude calculated fields', () => {\n      const model = parseUnitModel({\n        transform: [{calculate: 'datum[\"b\"] * 2', as: 'b2'}],\n        mark: 'point',\n        encoding: {\n          x: {field: 'a', type: 'temporal'},\n          y: {field: 'b', type: 'quantitative'},\n          color: {type: 'quantitative', aggregate: 'count'},\n          size: {field: 'b2', type: 'quantitative'}\n        }\n      });\n\n      const ancestorParse = new AncestorParse();\n      const parent = new DataFlowNode(null);\n      parseTransformArray(parent, model, ancestorParse);\n      expect(ancestorParse.combine()).toEqual({b2: 'derived'});\n      expect(ParseNode.makeImplicitFromEncoding(null, model, ancestorParse).parse).toEqual({\n        a: 'date'\n      });\n    });\n\n    it('should not parse fields with aggregate=missing/valid/distinct', () => {\n      const model = parseUnitModel({\n        mark: 'point',\n        encoding: {\n          x: {aggregate: 'missing', field: 'b', type: 'quantitative'},\n          y: {aggregate: 'valid', field: 'b', type: 'quantitative'},\n          color: {aggregate: 'distinct', field: 'b', type: 'quantitative'}\n        }\n      });\n\n      expect(ParseNode.makeImplicitFromEncoding(null, model, new AncestorParse())).toEqual(null);\n    });\n\n    it('should not parse the same field twice', () => {\n      const model = parseFacetModel({\n        data: {\n          values: [],\n          format: {\n            parse: {\n              a: 'number'\n            }\n          }\n        },\n        facet: {\n          row: {field: 'a', type: 'ordinal'}\n        },\n        spec: {\n          mark: 'point',\n          encoding: {\n            x: {field: 'a', type: 'quantitative'},\n            y: {field: 'b', type: 'temporal'}\n          }\n        }\n      });\n\n      expect(ParseNode.makeExplicit(null, model, new AncestorParse()).parse).toEqual({\n        a: 'number'\n      });\n      model.parseScale();\n      model.parseData();\n\n      expect(model.child.component.data.ancestorParse.combine()).toEqual({\n        a: 'number',\n        b: 'date'\n      });\n\n      // set the ancestor parse to see whether fields from it are not parsed\n      model.child.component.data.ancestorParse = new AncestorParse({a: 'number'});\n      expect(\n        ParseNode.makeImplicitFromEncoding(\n          null,\n          model.child as ModelWithField,\n          model.child.component.data.ancestorParse\n        ).parse\n      ).toEqual({\n        b: 'date'\n      });\n    });\n\n    it('should not parse the same field twice in explicit', () => {\n      const model = parseUnitModel({\n        data: {\n          values: [],\n          format: {\n            parse: {\n              a: 'number'\n            }\n          }\n        },\n        mark: 'point',\n        encoding: {}\n      });\n\n      expect(ParseNode.makeExplicit(null, model, new AncestorParse({a: 'number'}, {}))).toBeNull();\n    });\n\n    it('should not parse the same field twice in implicit', () => {\n      const model = parseUnitModel({\n        mark: 'point',\n        encoding: {\n          x: {field: 'a', type: 'quantitative'}\n        }\n      });\n\n      expect(ParseNode.makeExplicit(null, model, new AncestorParse({a: 'number'}, {}))).toBeNull();\n    });\n\n    it('should not parse counts', () => {\n      const model = parseUnitModel({\n        mark: 'point',\n        encoding: {\n          x: {aggregate: 'sum', field: 'foo', type: 'quantitative'},\n          y: {aggregate: 'count', type: 'quantitative'}\n        }\n      });\n\n      expect(ParseNode.makeImplicitFromEncoding(null, model, new AncestorParse())).toBeNull();\n    });\n\n    it('should add flatten for nested fields', () => {\n      const model = parseUnitModel({\n        mark: 'point',\n        encoding: {\n          x: {field: 'foo.bar', type: 'quantitative'},\n          y: {field: 'foo.baz', type: 'ordinal'}\n        }\n      });\n\n      expect(ParseNode.makeImplicitFromEncoding(null, model, new AncestorParse()).parse).toEqual({\n        'foo.bar': 'flatten',\n        'foo.baz': 'flatten'\n      });\n    });\n\n    it('should not parse if parse is disabled for a field', () => {\n      const model = parseUnitModel({\n        mark: 'point',\n        data: {\n          values: [],\n          format: {\n            parse: {\n              b: null\n            }\n          }\n        },\n        encoding: {\n          x: {field: 'a', type: 'quantitative'},\n          y: {field: 'b', type: 'quantitative'}\n        }\n      });\n\n      const ancestorParse = new AncestorParse();\n      expect(ParseNode.makeExplicit(null, model, ancestorParse)).toBeNull();\n      expect(ancestorParse.combine()).toEqual({\n        b: null\n      });\n      expect(ParseNode.makeImplicitFromEncoding(null, model, ancestorParse)).toBeNull();\n    });\n\n    it('should not parse if parse is disabled', () => {\n      const model = parseUnitModel({\n        mark: 'point',\n        data: {\n          values: [],\n          format: {\n            parse: null // implies AncestorParse.makeExplicit = true\n          }\n        },\n        encoding: {\n          x: {field: 'a', type: 'quantitative'},\n          y: {field: 'b', type: 'quantitative'}\n        }\n      });\n\n      expect(ParseNode.makeExplicit(null, model, new AncestorParse({}, {}, true))).toBeNull();\n    });\n  });\n\n  describe('assembleTransforms', () => {\n    it('should assemble correct parse expressions', () => {\n      const p = new ParseNode(null, {\n        n: 'number',\n        b: 'boolean',\n        s: 'string',\n        d1: 'date',\n        d2: 'date:\"%y\"',\n        d3: 'utc:\"%y\"',\n        d4: 'utc:%y',\n        d5: `utc:'%y'`\n      });\n\n      expect(p.assembleTransforms()).toEqual([\n        {type: 'formula', expr: 'toNumber(datum[\"n\"])', as: 'n'},\n        {type: 'formula', expr: 'toBoolean(datum[\"b\"])', as: 'b'},\n        {type: 'formula', expr: 'toString(datum[\"s\"])', as: 's'},\n        {type: 'formula', expr: 'toDate(datum[\"d1\"])', as: 'd1'},\n        {type: 'formula', expr: `timeParse(datum[\"d2\"],'%y')`, as: 'd2'},\n        {type: 'formula', expr: `utcParse(datum[\"d3\"],'%y')`, as: 'd3'},\n        {type: 'formula', expr: `utcParse(datum[\"d4\"],'%y')`, as: 'd4'},\n        {type: 'formula', expr: `utcParse(datum[\"d5\"],'%y')`, as: 'd5'}\n      ]);\n    });\n\n    it('should assemble flatten for nested fields', () => {\n      const p = new ParseNode(null, {\n        flat: 'number',\n        'nested.field': 'flatten'\n      });\n\n      expect(p.assembleTransforms(true)).toEqual([\n        {type: 'formula', expr: 'datum[\"nested\"] && datum[\"nested\"][\"field\"]', as: 'nested.field'}\n      ]);\n    });\n\n    it(\n      'should show warning for unrecognized types',\n      log.wrap(localLogger => {\n        const p = new ParseNode(null, {\n          x: 'foo'\n        });\n\n        expect(p.assembleTransforms()).toEqual([]);\n        expect(localLogger.warns[0]).toEqual(log.message.unrecognizedParse('foo'));\n      })\n    );\n  });\n\n  describe('assembleFormatParse', () => {\n    it('should assemble correct parse', () => {\n      const p = new ParseNode(null, {\n        n: 'number',\n        b: 'boolean',\n        'nested.field': 'flatten'\n      });\n\n      expect(p.assembleFormatParse()).toEqual({\n        n: 'number',\n        b: 'boolean'\n      });\n    });\n  });\n\n  describe('producedFields', () => {\n    it('should produce the correct fields', () => {\n      const p = new ParseNode(null, {\n        n: 'number',\n        b: 'boolean',\n        'nested.field': 'flatten'\n      });\n\n      expect(p.producedFields()).toEqual(new Set(['n', 'b', 'nested.field']));\n    });\n  });\n\n  describe('clone', () => {\n    it('should never clone parent', () => {\n      const parent = new DataFlowNode(null);\n      const parse = new ParseNode(parent, {});\n      expect(parse.clone().parent).toBeNull();\n    });\n  });\n});\n"]}