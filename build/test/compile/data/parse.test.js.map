{"version":3,"file":"parse.test.js","sourceRoot":"","sources":["../../../../test/compile/data/parse.test.ts"],"names":[],"mappings":"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","sourcesContent":["/* tslint:disable:quotemark */\nimport {AncestorParse} from '../../../src/compile/data';\nimport {AggregateNode} from '../../../src/compile/data/aggregate';\nimport {BinNode} from '../../../src/compile/data/bin';\nimport {CalculateNode} from '../../../src/compile/data/calculate';\nimport {DataFlowNode} from '../../../src/compile/data/dataflow';\nimport {FilterNode} from '../../../src/compile/data/filter';\nimport {FlattenTransformNode} from '../../../src/compile/data/flatten';\nimport {FoldTransformNode} from '../../../src/compile/data/fold';\nimport {ParseNode} from '../../../src/compile/data/formatparse';\nimport {ImputeNode} from '../../../src/compile/data/impute';\nimport {findSource, parseTransformArray} from '../../../src/compile/data/parse';\nimport {SampleTransformNode} from '../../../src/compile/data/sample';\nimport {TimeUnitNode} from '../../../src/compile/data/timeunit';\nimport {WindowTransformNode} from '../../../src/compile/data/window';\nimport {Transform} from '../../../src/transform';\nimport {parseUnitModel} from '../../util';\nimport {SourceNode} from './../../../src/compile/data/source';\n\ndescribe('compile/data/parse', () => {\n  describe('parseTransformArray()', () => {\n    it('should return a CalculateNode and a FilterNode', () => {\n      const model = parseUnitModel({\n        data: {values: []},\n        mark: 'point',\n        transform: [{calculate: 'calculate', as: 'as'}, {filter: 'filter'}],\n        encoding: {\n          x: {field: 'a', type: 'temporal', timeUnit: 'month'}\n        }\n      });\n\n      const root = new DataFlowNode(null);\n      const result = parseTransformArray(root, model, new AncestorParse());\n      expect(root.children[0] instanceof CalculateNode).toBe(true);\n      expect(result instanceof FilterNode).toBe(true);\n    });\n\n    it('should add a parse node for filter transforms with time unit', () => {\n      const model = parseUnitModel({\n        data: {url: 'a.json'},\n        transform: [\n          {\n            filter: {\n              not: {\n                and: [\n                  {\n                    or: [\n                      {\n                        timeUnit: 'year',\n                        field: 'date',\n                        equal: 2005\n                      },\n                      'datum.a > 5'\n                    ]\n                  }\n                ]\n              }\n            }\n          }\n        ],\n        mark: 'point',\n        encoding: {\n          x: {field: 'a', type: 'quantitative'},\n          y: {field: 'b', type: 'temporal'},\n          color: {field: 'c', type: 'ordinal'},\n          shape: {field: 'd', type: 'nominal'}\n        }\n      });\n\n      const root = new DataFlowNode(null);\n      const parse = new AncestorParse();\n      const result = parseTransformArray(root, model, parse);\n\n      expect(root.children[0] instanceof ParseNode).toBe(true);\n      expect(result instanceof FilterNode).toBe(true);\n      expect((root.children[0] as ParseNode).parse).toEqual({\n        date: 'date'\n      });\n      expect(parse.combine()).toEqual({date: 'date'});\n    });\n\n    it('should return a BinNode node and a TimeUnitNode', () => {\n      const model = parseUnitModel({\n        data: {values: []},\n        mark: 'point',\n        transform: [{bin: true, field: 'field', as: 'a'}, {timeUnit: 'month', field: 'field', as: 'b'}],\n        encoding: {\n          x: {field: 'a', type: 'temporal', timeUnit: 'month'}\n        }\n      });\n\n      const root = new DataFlowNode(null);\n      const parse = new AncestorParse();\n      const result = parseTransformArray(root, model, parse);\n      expect(root.children[0] instanceof BinNode);\n      expect(result instanceof TimeUnitNode);\n      expect(parse.combine()).toEqual({a: 'number', a_end: 'number', b: 'date', field: 'date'});\n    });\n\n    it('should return a BinNode and a AggregateNode', () => {\n      const model = parseUnitModel({\n        data: {values: []},\n        mark: 'point',\n        transform: [\n          {bin: true, field: 'field', as: 'a'},\n          {aggregate: [{op: 'count', field: 'f', as: 'b'}, {op: 'sum', field: 'f', as: 'c'}], groupby: ['field']}\n        ],\n        encoding: {\n          x: {field: 'a', type: 'temporal', timeUnit: 'month'}\n        }\n      });\n\n      const root = new DataFlowNode(null);\n      const result = parseTransformArray(root, model, new AncestorParse());\n      expect(root.children[0] instanceof BinNode).toBe(true);\n      expect(result instanceof AggregateNode).toBe(true);\n    });\n\n    it('should return a ImputeTransform Node', () => {\n      const model = parseUnitModel({\n        data: {values: []},\n        mark: 'point',\n        transform: [{impute: 'x', key: 'y', method: 'mean'}],\n        encoding: {\n          x: {field: 'a', type: 'temporal'},\n          y: {field: 'b', type: 'quantitative'}\n        }\n      });\n      const root = new DataFlowNode(null);\n      const result = parseTransformArray(root, model, new AncestorParse());\n      expect(root.children[0] instanceof ImputeNode).toBe(true);\n      expect(result instanceof ImputeNode).toBe(true);\n    });\n    it('should return a WindowTransform Node', () => {\n      const transform: Transform = {\n        window: [\n          {\n            op: 'count',\n            field: 'f',\n            as: 'b'\n          }\n        ]\n      };\n      const model = parseUnitModel({\n        data: {values: []},\n        mark: 'point',\n        transform: [transform],\n        encoding: {\n          x: {field: 'a', type: 'temporal', timeUnit: 'month'}\n        }\n      });\n      const root = new DataFlowNode(null);\n      parseTransformArray(root, model, new AncestorParse());\n      expect(root.children[0] instanceof WindowTransformNode).toBe(true);\n    });\n    it('should return a WindowTransform Node with optional properties', () => {\n      const transform: Transform = {\n        window: [\n          {\n            op: 'row_number',\n            as: 'ordered_row_number'\n          }\n        ],\n        ignorePeers: false,\n        sort: [\n          {\n            field: 'f',\n            order: 'ascending'\n          }\n        ]\n      };\n      const model = parseUnitModel({\n        data: {values: []},\n        mark: 'point',\n        transform: [transform],\n        encoding: {\n          x: {field: 'a', type: 'temporal', timeUnit: 'month'}\n        }\n      });\n      const root = new DataFlowNode(null);\n      parseTransformArray(root, model, new AncestorParse());\n      expect(root.children[0] instanceof WindowTransformNode).toBe(true);\n    });\n\n    it('should return a WindowTransform Node', () => {\n      const transform: Transform = {\n        window: [\n          {\n            op: 'count',\n            field: 'f',\n            as: 'b'\n          }\n        ]\n      };\n      const model = parseUnitModel({\n        data: {values: []},\n        mark: 'point',\n        transform: [transform],\n        encoding: {\n          x: {field: 'a', type: 'temporal', timeUnit: 'month'}\n        }\n      });\n      const root = new DataFlowNode(null);\n      parseTransformArray(root, model, new AncestorParse());\n      expect(root.children[0] instanceof WindowTransformNode).toBe(true);\n    });\n    it('should return a WindowTransform Node with optional properties', () => {\n      const transform: Transform = {\n        window: [\n          {\n            op: 'row_number',\n            as: 'ordered_row_number'\n          }\n        ],\n        ignorePeers: false,\n        sort: [\n          {\n            field: 'f',\n            order: 'ascending'\n          }\n        ]\n      };\n      const model = parseUnitModel({\n        data: {values: []},\n        mark: 'point',\n        transform: [transform],\n        encoding: {\n          x: {field: 'a', type: 'temporal', timeUnit: 'month'}\n        }\n      });\n      const root = new DataFlowNode(null);\n      parseTransformArray(root, model, new AncestorParse());\n      expect(root.children[0] instanceof WindowTransformNode).toBe(true);\n    });\n\n    it('should return a FoldTransformNode', () => {\n      const transform: Transform = {\n        fold: ['a', 'b'],\n        as: ['A', 'B']\n      };\n      const model = parseUnitModel({\n        data: {values: []},\n        mark: 'point',\n        transform: [transform],\n        encoding: {\n          x: {field: 'A', type: 'temporal'},\n          y: {field: 'B', type: 'quantitative'}\n        }\n      });\n      const root = new DataFlowNode(null);\n      const result = parseTransformArray(root, model, new AncestorParse());\n      expect(root.children[0] instanceof FoldTransformNode).toBe(true);\n      expect(result instanceof FoldTransformNode).toBe(true);\n    });\n\n    it('should return a FlattenTransformNode', () => {\n      const transform: Transform = {\n        flatten: ['a', 'b']\n      };\n      const model = parseUnitModel({\n        data: {values: []},\n        mark: 'point',\n        transform: [transform],\n        encoding: {\n          x: {field: 'a', type: 'temporal'},\n          y: {field: 'b', type: 'quantitative'}\n        }\n      });\n      const root = new DataFlowNode(null);\n      const result = parseTransformArray(root, model, new AncestorParse());\n      expect(root.children[0] instanceof FlattenTransformNode).toBe(true);\n      expect(result instanceof FlattenTransformNode).toBe(true);\n    });\n\n    it('should return a SampleTransformNode', () => {\n      const transform: Transform = {\n        sample: 1000\n      };\n      const model = parseUnitModel({\n        data: {values: []},\n        mark: 'point',\n        transform: [transform],\n        encoding: {\n          x: {field: 'A', type: 'temporal'},\n          y: {field: 'B', type: 'quantitative'}\n        }\n      });\n      const root = new DataFlowNode(null);\n      const result = parseTransformArray(root, model, new AncestorParse());\n      expect(root.children[0] instanceof SampleTransformNode).toBe(true);\n      expect(result instanceof SampleTransformNode).toBe(true);\n    });\n\n    it('should return a 3 Transforms from an Impute', () => {\n      const transform: Transform = {\n        impute: 'y',\n        key: 'x',\n        method: 'max',\n        groupby: ['a', 'b'],\n        frame: [-2, 2]\n      };\n\n      const model = parseUnitModel({\n        data: {values: []},\n        mark: 'point',\n        transform: [transform],\n        encoding: {\n          x: {field: 'x', type: 'quantitative'},\n          y: {field: 'y', type: 'quantitative'},\n          color: {field: 'c', type: 'nominal'}\n        }\n      });\n      const root = new DataFlowNode(null);\n      const result = parseTransformArray(root, model, new AncestorParse());\n      expect(root.children[0] instanceof ImputeNode).toBe(true);\n      expect(result instanceof ImputeNode).toBe(true);\n    });\n  });\n\n  describe('findSource', () => {\n    const values = new SourceNode({values: [1, 2, 3]});\n    const named = new SourceNode({name: 'foo'});\n    const url = new SourceNode({url: 'foo.csv'});\n\n    it('should find named source', () => {\n      const actual = findSource({name: 'foo'}, [values, named, url]);\n      expect(actual).toBe(named);\n    });\n\n    it('should find value source', () => {\n      const actual = findSource({values: [1, 2, 3]}, [values, named, url]);\n      expect(actual).toBe(values);\n    });\n\n    it('should find url source', () => {\n      const actual = findSource({url: 'foo.csv'}, [values, named, url]);\n      expect(actual).toBe(url);\n    });\n\n    it('should not find new data source', () => {\n      const actual = findSource({url: 'bar.csv'}, [values, named, url]);\n      expect(actual).toBeNull();\n    });\n  });\n});\n"]}